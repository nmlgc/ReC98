; ---------------------------------------------------------------------------

FILE		struc ;	(sizeof=0x10, standard type)
level		dw ?
flags		dw ?
fd		db ?
hold		db ?
bsize		dw ?
buffer		dw ?			; offset
curp		dw ?			; offset
istemp		dw ?
token		dw ?			; offset (00000000)
FILE		ends


;
; +-------------------------------------------------------------------------+
; |   This file has been generated by The Interactive Disassembler (IDA)    |
; |        Copyright (c) 2009 by Hex-Rays, <support@hex-rays.com>           |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	4985DF302FBB4A988F4F8E85A083BC00

; File Name   :	th05/ZUN.COM:-S
; Format      :	MS-DOS COM-file
; Base Address:	0h Range: 100h-1AA4h Loaded length: 19A4h
; OS type	  :  MS	DOS
; Application type:  Executable	16bit

		.386
		.model tiny

; ===========================================================================

; Segment type:	Pure code
seg000		segment	byte public 'CODE' use16
		assume cs:seg000
		org 100h
		assume es:nothing, ss:nothing, ds:seg000, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn

		public start
start		proc near
		mov	dx, cs
		mov	cs:DGROUP@, dx
		mov	ah, 30h
		int	21h		; DOS -	GET DOS	VERSION
					; Return: AL = major version number (00h for DOS 1.x)
		mov	bp, ds:2
		mov	bx, ds:2Ch
		mov	ds, dx
		mov	word_16A8, ax
		mov	word_16A6, es
		mov	word_16A2, bx
		mov	word_16BC, bp
		call	sub_26E
		mov	ax, word_16A2
		mov	es, ax
		xor	ax, ax
		mov	bx, ax
		mov	di, ax
		mov	cx, 7FFFh
		cld

loc_136:
		repne scasb
		jcxz	short loc_19B
		inc	bx
		cmp	es:[di], al
		jnz	short loc_136
		or	ch, 80h
		neg	cx
		mov	word_16A0, cx
		mov	cx, 1
		shl	bx, cl
		add	bx, 8
		and	bx, 0FFF8h
		mov	word_16A4, bx
		mov	dx, ds
		sub	bp, dx
		mov	di, word_1A68
		cmp	di, 200h
		jnb	short loc_16D
		mov	di, 200h
		mov	word_1A68, di

loc_16D:
		add	di, offset edata@
		jb	short loc_19B
		add	di, word_1A0A
		jb	short loc_19B
		mov	cl, 4
		shr	di, cl
		inc	di
		cmp	bp, di
		jb	short loc_19B
		cmp	word_1A68, 0
		jz	short loc_190
		cmp	word_1A0A, 0
		jnz	short loc_19E

loc_190:
		mov	di, 1000h
		cmp	bp, di
		ja	short loc_19E
		mov	di, bp
		jmp	short loc_19E
; ---------------------------------------------------------------------------

loc_19B:
		call	sub_9D6
; ---------------------------------------------------------------------------

loc_19E:
		mov	bx, di
		add	bx, dx
		mov	word_16B4, bx
		mov	word_16B8, bx
		mov	ax, word_16A6
		sub	bx, ax
		mov	es, ax
		mov	ah, 4Ah
		push	di
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		pop	di
		shl	di, cl
		cli
		mov	ss, dx
		mov	sp, di
		sti
		xor	ax, ax
		mov	es, cs:DGROUP@
		mov	di, offset bdata@
		mov	cx, offset edata@
		sub	cx, di
		cld
		rep stosb
		cmp	word_19E0, 14h
		jbe	short loc_21F
		cmp	byte ptr word_16A8, 3
		jb	short loc_21F
		ja	short loc_1E8
		cmp	byte ptr word_16A8+1, 1Eh
		jb	short loc_21F

loc_1E8:
		mov	ax, 5801h
		mov	bx, 2
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		jb	short loc_21C
		mov	ah, 67h
		mov	bx, word_19E0
		int	21h		; DOS -	3.3+ - SET HANDLE COUNT
					; BX = desired number of handles (max 255)
		jb	short loc_21C
		mov	ah, 48h
		mov	bx, 1
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short loc_21C
		inc	ax
		mov	word_16BC, ax
		dec	ax
		mov	es, ax
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		jb	short loc_21C
		mov	ax, 5801h
		mov	bx, 0
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		jnb	short loc_21F

loc_21C:
		call	sub_9D6
; ---------------------------------------------------------------------------

loc_21F:
		xor	bp, bp
		mov	es, cs:DGROUP@
		assume es:nothing
		mov	si, offset InitStart
		mov	di, offset bdata@
		call	sub_2DE
		push	envp		; envp
		push	argv		; argv
		push	argc		; argc
		call	_main
		push	ax		; status
		call	_exit
; ---------------------------------------------------------------------------

__cleanup:
		mov	es, cs:DGROUP@
		push	si
		push	di
		mov	si, offset bdata@
		mov	di, offset bdata@
		call	sub_322
		pop	di
		pop	si
		retn
start		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

__checknull	proc near
		retn
__checknull	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn	bp-based frame

__terminate	proc near

arg_0		= byte ptr  2

		mov	bp, sp
		mov	ah, 4Ch
		mov	al, [bp+arg_0]
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
__terminate	endp			; AL = exit code


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

sub_25F		proc near
		mov	dx, offset aDivideError	; "Divide error\r\n"
		push	dx		; buf
		call	___ErrorMessage
		pop	dx
		mov	ax, 3
		push	ax		; status
		call	__exit
sub_25F		endp


; =============== S U B	R O U T	I N E =======================================


sub_26E		proc near
		push	ds
		mov	ax, 3500h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_168A, bx
		mov	word ptr dword_168A+2, es
		mov	ax, 3504h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_168E, bx
		mov	word ptr dword_168E+2, es
		mov	ax, 3505h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_1692, bx
		mov	word ptr dword_1692+2, es
		mov	ax, 3506h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_1696, bx
		mov	word ptr dword_1696+2, es
		mov	ax, 2500h
		mov	dx, cs
		mov	ds, dx
		mov	dx, offset sub_25F
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		retn
sub_26E		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

__restorezero	proc near
		push	ds
		mov	ax, 2500h
		lds	dx, dword_168A
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		push	ds
		mov	ax, 2504h
		lds	dx, dword_168E
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		push	ds
		mov	ax, 2505h
		lds	dx, dword_1692
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		push	ds
		mov	ax, 2506h
		lds	dx, dword_1696
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		retn
__restorezero	endp


; =============== S U B	R O U T	I N E =======================================


sub_2DE		proc near
		mov	ax, 100h
		mov	dx, di
		mov	bx, si

loc_2E5:
		cmp	bx, di
		jz	short loc_302
		cmp	byte ptr es:[bx], 0FFh
		jz	short loc_2FD
		mov	cl, es:[bx+1]
		xor	ch, ch
		cmp	cx, ax
		jnb	short loc_2FD
		mov	ax, cx
		mov	dx, bx

loc_2FD:
		add	bx, 6
		jmp	short loc_2E5
; ---------------------------------------------------------------------------

loc_302:
		cmp	dx, di
		jz	short locret_321
		mov	bx, dx
		cmp	byte ptr es:[bx], 0
		mov	byte ptr es:[bx], 0FFh
		push	es
		jz	short loc_31A
		call	dword ptr es:[bx+2]
		pop	es
		jmp	short sub_2DE
; ---------------------------------------------------------------------------

loc_31A:
		call	word ptr es:[bx+2]
		pop	es
		jmp	short sub_2DE
; ---------------------------------------------------------------------------

locret_321:
		retn
sub_2DE		endp


; =============== S U B	R O U T	I N E =======================================


sub_322		proc near
		mov	ah, 0
		mov	dx, di
		mov	bx, si

loc_328:
		cmp	bx, di
		jz	short loc_343
		cmp	byte ptr es:[bx], 0FFh
		jz	short loc_33E
		cmp	es:[bx+1], ah
		jb	short loc_33E
		mov	ah, es:[bx+1]
		mov	dx, bx

loc_33E:
		add	bx, 6
		jmp	short loc_328
; ---------------------------------------------------------------------------

loc_343:
		cmp	dx, di
		jz	short locret_362
		mov	bx, dx
		cmp	byte ptr es:[bx], 0
		mov	byte ptr es:[bx], 0FFh
		push	es
		jz	short loc_35B
		call	dword ptr es:[bx+2]
		pop	es
		jmp	short sub_322
; ---------------------------------------------------------------------------

loc_35B:
		call	word ptr es:[bx+2]
		pop	es
		jmp	short sub_322
; ---------------------------------------------------------------------------

locret_362:
		retn
sub_322		endp

; ---------------------------------------------------------------------------
DGROUP@		dw 0
__MMODEL	db 2 dup(0)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_367		proc near

var_14		= dword	ptr -14h
var_10		= byte ptr -10h
var_F		= byte ptr -0Fh
var_E		= byte ptr -0Eh
var_D		= byte ptr -0Dh
var_C		= byte ptr -0Ch
var_B		= byte ptr -0Bh
var_7		= byte ptr -7
var_6		= byte ptr -6
arg_0		= word ptr  4

		enter	14h, 0
		push	si
		mov	si, offset aMiko_cfg ; "miko.cfg"
		lea	ax, [bp+var_6]
		push	ss
		push	ax
		push	ds
		push	offset unk_16BF
		mov	cx, 6
		call	N_SCOPY@
		mov	ax, [bp+arg_0]
		mov	word ptr [bp+var_14+2],	ax
		mov	word ptr [bp+var_14], 0
		push	si
		call	sub_7C6
		or	ax, ax
		jnz	short loc_3CA

loc_391:
		push	si
		call	sub_8A2
		or	ax, ax
		jnz	short loc_39C
		jmp	loc_48A
; ---------------------------------------------------------------------------

loc_39C:
		push	ss
		lea	ax, [bp+var_6]
		push	ax
		push	6
		call	sub_7FC
		les	bx, [bp+var_14]
		mov	byte ptr es:[bx+11h], 0FFh
		mov	byte ptr es:[bx+0Fh], 3
		mov	byte ptr es:[bx+10h], 3
		mov	byte ptr es:[bx+12h], 1
		mov	byte ptr es:[bx+15h], 1
		mov	byte ptr es:[bx+16h], 1
		jmp	loc_47C
; ---------------------------------------------------------------------------

loc_3CA:
		push	ss
		lea	ax, [bp+var_10]
		push	ax
		push	0Ah
		call	sub_698
		call	sub_7B8
		mov	al, [bp+var_10]
		cbw
		push	ax
		mov	al, [bp+var_F]
		cbw
		pop	dx
		add	dx, ax
		mov	al, [bp+var_E]
		cbw
		add	dx, ax
		mov	al, [bp+var_D]
		cbw
		add	dx, ax
		mov	al, [bp+var_C]
		cbw
		add	dx, ax
		mov	al, [bp+var_B]
		cbw
		add	dx, ax
		mov	al, [bp+var_7]
		cbw
		cmp	dx, ax
		jnz	short loc_391
		les	bx, [bp+var_14]
		mov	al, [bp+var_10]
		mov	es:[bx+11h], al
		mov	al, [bp+var_F]
		mov	es:[bx+0Fh], al
		mov	al, [bp+var_E]
		mov	es:[bx+10h], al
		mov	al, [bp+var_D]
		mov	es:[bx+12h], al
		mov	al, [bp+var_C]
		mov	es:[bx+15h], al
		mov	al, [bp+var_B]
		mov	es:[bx+16h], al
		cmp	byte ptr es:[bx+0Fh], 6
		jbe	short loc_43A
		jmp	loc_391
; ---------------------------------------------------------------------------

loc_43A:
		cmp	byte ptr es:[bx+0Fh], 0
		jnz	short loc_444
		jmp	loc_391
; ---------------------------------------------------------------------------

loc_444:
		les	bx, [bp+var_14]
		cmp	byte ptr es:[bx+10h], 3
		jbe	short loc_451
		jmp	loc_391
; ---------------------------------------------------------------------------

loc_451:
		les	bx, [bp+var_14]
		cmp	byte ptr es:[bx+12h], 3
		jb	short loc_45E
		jmp	loc_391
; ---------------------------------------------------------------------------

loc_45E:
		les	bx, [bp+var_14]
		cmp	byte ptr es:[bx+15h], 3
		jb	short loc_46B
		jmp	loc_391
; ---------------------------------------------------------------------------

loc_46B:
		push	si
		call	sub_920
		or	ax, ax
		jz	short loc_48A
		push	0
		push	6
		push	0
		call	sub_8DE

loc_47C:
		push	ss
		lea	ax, [bp+arg_0]
		push	ax
		push	2
		call	sub_7FC
		or	ax, ax
		jnz	short loc_48E

loc_48A:
		mov	al, 1
		jmp	short loc_4A6
; ---------------------------------------------------------------------------

loc_48E:
		push	ds
		push	offset byte_16BE
		push	1
		call	sub_7FC
		push	ss
		lea	ax, [bp+var_7]
		push	ax
		push	1
		call	sub_7FC
		call	sub_7B8
		mov	al, 0

loc_4A6:
		pop	si
		leave
		retn
sub_367		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
_main		proc near

var_C		= word ptr -0Ch
var_A		= dword	ptr -0Ah
var_6		= dword	ptr -6
var_2		= word ptr -2
_argc		= word ptr  4
_argv		= word ptr  6
_envp		= word ptr  8

		enter	0Ch, 0
		push	si
		push	di
		mov	si, [bp+_argv]
		mov	[bp+var_C], offset aKsoconfig ;	"KSOConfig"
		push	[bp+var_C]
		push	9
		push	8
		call	sub_5DA
		mov	di, ax
		push	offset aUmx	; "\n\n東方怪綺談用　 常駐プログラム　	    "...
		call	sub_996
		call	sub_5B6
		cmp	[bp+_argc], 2
		jnz	short loc_530
		mov	bx, [si+2]
		cmp	byte ptr [bx], '-'
		jz	short loc_4DF
		cmp	byte ptr [bx], '/'
		jnz	short loc_505

loc_4DF:
		mov	bx, [si+2]
		cmp	byte ptr [bx+1], 'R'
		jz	short loc_4EE
		cmp	byte ptr [bx+1], 'r'
		jnz	short loc_505

loc_4EE:
		or	di, di
		jnz	short loc_4F8
		push	offset aVVVvvVV	; "まだいませんよぉ\n\n"
		jmp	loc_58D
; ---------------------------------------------------------------------------

loc_4F8:
		push	di
		call	sub_970
		push	offset aVVsvqvBBavVIqv ; "じゃぁねー、また会えるよね\n\n"
		call	sub_996
		jmp	loc_5B0
; ---------------------------------------------------------------------------

loc_505:
		mov	bx, [si+2]
		cmp	byte ptr [bx], '-'
		jz	short loc_512
		cmp	byte ptr [bx], '/'
		jnz	short loc_528

loc_512:
		mov	bx, [si+2]
		cmp	byte ptr [bx+1], 'D'
		jz	short loc_521
		cmp	byte ptr [bx+1], 'd'
		jnz	short loc_528

loc_521:
		mov	byte_16BE, 1
		jmp	short loc_530
; ---------------------------------------------------------------------------

loc_528:
		push	offset aVV	; "そんなオプション付けられても、困るんで・...
		call	sub_996
		jmp	short loc_590
; ---------------------------------------------------------------------------

loc_530:
		or	di, di
		jz	short loc_53C
		push	offset aVavVBavVVVvvVV ; "わたし、すでにいますよぉ\n\n"
		call	sub_996
		jmp	short loc_590
; ---------------------------------------------------------------------------

loc_53C:
		push	[bp+var_C]
		push	9
		push	8
		call	sub_622
		mov	di, ax
		or	di, di
		jnz	short loc_554
		push	offset aNVVVV	; "作れません、わたしの居場所がないの！\n\n"
		call	sub_996
		jmp	short loc_590
; ---------------------------------------------------------------------------

loc_554:
		mov	word ptr [bp+var_A+2], di
		mov	word ptr [bp+var_A], 0
		push	offset aVivVsvVVBVBb ; "おじゃましまーす。\n\n"
		call	sub_996
		mov	[bp+var_2], 0Ah
		jmp	short loc_576
; ---------------------------------------------------------------------------

loc_569:
		les	bx, [bp+var_A]
		add	bx, [bp+var_2]
		mov	byte ptr es:[bx], 0
		inc	[bp+var_2]

loc_576:
		cmp	[bp+var_2], 80h
		jl	short loc_569
		push	di
		call	sub_367
		pop	cx
		or	al, al
		jz	short loc_595
		push	di
		call	sub_970
		push	offset aGtg@gcglvkpsvl ; "ファイルが書き込めないの〜\n\n"

loc_58D:
		call	sub_996

loc_590:
		mov	ax, 1
		jmp	short loc_5B2
; ---------------------------------------------------------------------------

loc_595:
		mov	dx, word ptr [bp+var_A+2]
		mov	ax, word ptr [bp+var_A]
		mov	word ptr [bp+var_6+2], dx
		mov	word ptr [bp+var_6], ax
		cmp	byte_16BE, 0
		jz	short loc_5B0
		les	bx, [bp+var_6]
		mov	byte ptr es:[bx+17h], 1

loc_5B0:
		xor	ax, ax

loc_5B2:
		pop	di
		pop	si
		leave
		retn
_main		endp


; =============== S U B	R O U T	I N E =======================================


sub_5B6		proc near
		mov	al, 80h
		pushf
		cli
		out	7Ch, al
		popf
		xor	ax, ax
		mov	dx, 7Eh
		out	dx, al
		out	dx, al
		out	dx, al
		out	dx, al
		mov	bx, di
		xor	di, di
		mov	cx, word_185E
		mov	es, word_185C
		assume es:nothing
		rep stosw
		mov	di, bx
		out	7Ch, al
		retn
sub_5B6		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_5DA		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ah, 52h
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		cld
		mov	bx, es:[bx-2]

loc_5E8:
		mov	es, bx
		assume es:nothing
		inc	bx
		mov	ax, es:1
		or	ax, ax
		jz	short loc_609
		mov	ax, es:3
		cmp	ax, [bp+arg_0]
		jnz	short loc_609
		mov	cx, [bp+arg_2]
		mov	si, [bp+arg_4]
		mov	di, 10h
		repe cmpsb
		jz	short loc_61A

loc_609:
		mov	ax, es:3
		add	bx, ax
		mov	al, es:0
		cmp	al, 4Dh
		jz	short loc_5E8
		mov	bx, 0

loc_61A:
		mov	ax, bx
		pop	di
		pop	si
		pop	bp
		retn	6
sub_5DA		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_622		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+arg_4]
		push	[bp+arg_2]
		push	[bp+arg_0]
		call	sub_5DA
		or	ax, ax
		jnz	short loc_691
		mov	ax, 5800h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: get allocation strategy
		mov	dx, ax
		mov	ax, 5801h
		mov	bx, 1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	ah, 48h
		mov	bx, [bp+arg_0]
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	cx, 0
		jb	short loc_688
		mov	bx, cs
		cmp	bx, ax
		jnb	short loc_66D
		mov	es, ax
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	ax, 5801h
		mov	bx, 2
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	ah, 48h
		mov	bx, [bp+arg_0]
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired

loc_66D:
		mov	cx, ax
		push	ax
		dec	cx
		mov	es, cx
		assume es:nothing
		mov	ax, 0FFFFh
		mov	es:1, ax
		inc	cx
		mov	es, cx
		assume es:nothing
		xor	di, di
		mov	cx, [bp+arg_2]
		mov	si, [bp+arg_4]
		rep movsb
		pop	cx

loc_688:
		mov	ax, 5801h
		mov	bx, dx
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	ax, cx

loc_691:
		pop	di
		pop	si
		pop	bp
		retn	6
sub_622		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_698		proc near

arg_0		= word ptr  4
arg_2		= dword	ptr  6

		push	bp
		mov	bp, sp
		push	si
		push	di
		cmp	word_1872, 0
		jz	short loc_71C
		mov	bx, [bp+arg_0]
		les	di, [bp+arg_2]
		assume es:nothing

loc_6AA:
		mov	ax, word ptr unk_1AB4
		cmp	word_1AB2, ax
		jb	short loc_6E0
		add	word_1AAE, ax
		adc	word_1AB0, 0
		push	bx
		push	ds
		mov	cx, word_1872
		mov	bx, word_1874
		lds	dx, dword ptr unk_1AAA
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds
		pop	bx
		cmc
		sbb	dx, dx
		and	ax, dx
		mov	word ptr unk_1AB4, ax
		jz	short loc_73B
		mov	word_1AB2, 0

loc_6E0:
		mov	si, word ptr unk_1AB4
		sub	si, word_1AB2
		sub	si, bx
		sbb	ax, ax
		and	si, ax
		add	si, bx
		mov	ax, es
		or	ax, di
		jz	short loc_711
		or	si, si
		jz	short loc_711
		push	si
		push	ds
		mov	cx, si
		mov	ax, word_1AB2
		lds	si, dword ptr unk_1AAA
		add	si, ax
		shr	cx, 1
		rep movsw
		adc	cx, cx
		rep movsb
		pop	ds
		pop	si

loc_711:
		add	word_1AB2, si
		sub	bx, si
		jnz	short loc_6AA
		jmp	short loc_741
; ---------------------------------------------------------------------------
		nop

loc_71C:
		push	ds
		mov	cx, [bp+arg_0]
		mov	bx, word_1874
		lds	dx, [bp+arg_2]
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds
		add	word_1AAE, ax
		adc	word_1AB0, 0
		mov	bx, cx
		sub	bx, ax
		jz	short loc_741

loc_73B:
		mov	word ptr unk_1AB6, 1

loc_741:
		mov	ax, [bp+arg_0]
		sub	ax, bx
		pop	di
		pop	si
		pop	bp
		retn	6
sub_698		endp


; =============== S U B	R O U T	I N E =======================================


sub_74C		proc near
		mov	bx, word_1874
		cmp	bx, 0FFFFh
		jz	short locret_7B6
		mov	ax, word_1AB2
		cmp	word ptr unk_1AB4, ax
		jnb	short loc_78A
		push	ds
		mov	cx, word_1AB2
		lds	dx, dword ptr unk_1AAA
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	ds
		jb	short loc_77D
		add	word_1AAE, ax
		adc	word_1AB0, 0
		cmp	word_1AB2, ax
		jz	short loc_783

loc_77D:
		mov	word ptr unk_1AB8, 1

loc_783:
		mov	word_1AB2, 0
		retn
; ---------------------------------------------------------------------------

loc_78A:
		cmp	word ptr unk_1AB4, 0
		jz	short locret_7B6
		mov	dx, ax
		mov	cx, 0
		add	dx, word_1AAE
		mov	word ptr unk_1AB4, cx
		mov	word_1AB2, cx
		adc	cx, word_1AB0
		mov	ax, 4200h
		mov	bx, word_1874
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		mov	word_1AAE, ax
		mov	word_1AB0, dx

locret_7B6:
		retn
sub_74C		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_7B8		proc near
		call	sub_74C
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	word_1874, 0FFFFh
		retn
sub_7B8		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_7C6		proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		xor	ax, ax
		mov	bx, word_1874
		cmp	bx, 0FFFFh
		jnz	short loc_7F8
		push	[bp+arg_0]
		call	sub_9BE
		sbb	bx, bx
		or	ax, bx
		mov	word_1874, ax
		xor	ax, ax
		mov	word ptr unk_1AB4, ax
		mov	word_1AAE, ax
		mov	word_1AB0, ax
		mov	word_1AB2, ax
		mov	word ptr unk_1AB6, ax
		mov	word ptr unk_1AB8, ax
		lea	ax, [bx+1]

loc_7F8:
		pop	bp
		retn	2
sub_7C6		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_7FC		proc near

arg_0		= word ptr  4
arg_2		= dword	ptr  6

		push	bp
		mov	bp, sp
		push	si
		push	di
		cmp	word_1872, 0
		jz	short loc_872
		mov	bx, [bp+arg_0]
		mov	si, word ptr [bp+arg_2]

loc_80E:
		mov	cx, word_1872
		sub	cx, word_1AB2
		sub	cx, bx
		sbb	ax, ax
		and	cx, ax
		add	cx, bx
		les	di, dword ptr unk_1AAA
		add	di, word_1AB2
		sub	bx, cx
		add	word_1AB2, cx
		push	ds
		mov	ds, word ptr [bp+arg_2+2]
		shr	cx, 1
		rep movsw
		adc	cx, cx
		rep movsb
		pop	ds
		or	ax, ax
		jns	short loc_868
		push	ds
		push	bx
		mov	cx, word_1872
		mov	bx, word_1874
		lds	dx, dword ptr unk_1AAA
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	bx
		pop	ds
		jb	short loc_884
		cmp	word_1872, ax
		jnz	short loc_884
		mov	word_1AB2, 0
		add	word_1AAE, ax
		adc	word_1AB0, 0

loc_868:
		or	bx, bx
		jnz	short loc_80E
		mov	ax, 1
		jmp	short loc_89A
; ---------------------------------------------------------------------------
		nop

loc_872:
		push	ds
		mov	cx, [bp+arg_0]
		mov	bx, word_1874
		lds	dx, [bp+arg_2]
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	ds
		jnb	short loc_88C

loc_884:
		mov	word ptr unk_1AB8, 1
		xor	ax, ax

loc_88C:
		add	word_1AAE, ax
		adc	word_1AB0, 0
		add	ax, 0FFFFh
		sbb	ax, ax

loc_89A:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn	6
sub_7FC		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_8A2		proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		mov	ax, 0
		mov	bx, word_1874
		cmp	bx, 0FFFFh
		jnz	short loc_8D9
		mov	cx, 20h
		mov	ah, 3Ch
		push	ax
		push	[bp+arg_0]
		call	sub_980
		or	ax, dx
		mov	word_1874, ax
		xor	ax, ax
		mov	word ptr unk_1AB4, ax
		mov	word_1AB2, ax
		mov	word ptr unk_1AB6, ax
		mov	word ptr unk_1AB8, ax
		mov	word_1AAE, ax
		mov	word_1AB0, ax
		mov	ax, dx
		inc	ax

loc_8D9:
		pop	bp
		retn	2
sub_8A2		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_8DE		proc near
		call	sub_74C
		cmp	bx, 0FFFFh
		jz	short locret_90E
		push	bp
		mov	bp, sp
		mov	al, [bp+4]
		mov	ah, 42h
		mov	dx, [bp+6]
		mov	cx, [bp+8]
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method:
					; 0-from beginnig,1-from current,2-from	end
		pop	bp
		mov	ax, 4201h
		mov	dx, 0
		mov	cx, dx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from present location
		mov	word ptr unk_1AB6, 0
		mov	word_1AAE, ax
		mov	word_1AB0, dx

locret_90E:
		retn	6
sub_8DE		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_912		proc near
		mov	ax, word_1AB2
		xor	dx, dx
		add	ax, word_1AAE
		adc	dx, word_1AB0
		retn
sub_912		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_920		proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		mov	ax, 0
		mov	bx, word_1874
		cmp	bx, 0FFFFh
		jnz	short loc_96C
		mov	ax, 3D02h
		push	ax
		push	[bp+arg_0]
		call	sub_980
		or	ax, dx
		mov	word_1874, ax
		mov	cx, ax
		xor	ax, ax
		mov	word ptr unk_1AB4, ax
		mov	word_1AB2, ax
		mov	word ptr unk_1AB6, ax
		mov	word ptr unk_1AB8, ax
		mov	word_1AAE, ax
		mov	word_1AB0, ax
		inc	dx
		jz	short loc_96C
		mov	bx, cx
		xor	cx, cx
		mov	dx, cx
		mov	ax, 4202h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		mov	word_1AAE, ax
		mov	word_1AB0, dx
		mov	ax, 1

loc_96C:
		pop	bp
		retn	2
sub_920		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_970		proc near

arg_0		= word ptr  6

		push	bp
		push	es
		mov	bp, sp
		mov	es, [bp+arg_0]
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es
		pop	bp
		retn	2
sub_970		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_980		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6

		push	bp
		mov	bp, sp
		mov	dx, [bp+arg_0]
		mov	ax, [bp+arg_2]
		int	21h		; DOS -
		sbb	dx, dx
		xor	ax, dx
		sub	ax, dx
		pop	bp
		retn	4
sub_980		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_996		proc near
		mov	bx, sp
		mov	cx, si
		mov	si, ss:[bx+2]
		lodsb
		or	al, al
		jz	short loc_9B8
		mov	ah, 2

loc_9A5:
		cmp	al, 0Ah
		jnz	short loc_9AF
		mov	dl, 0Dh
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		mov	al, 0Ah

loc_9AF:
		mov	dl, al
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		lodsb
		or	al, al
		jnz	short loc_9A5

loc_9B8:
		mov	si, cx
		retn	2
sub_996		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_9BE		proc near
		mov	bx, sp
		mov	ah, 3Dh
		mov	al, byte_1876
		mov	dx, ss:[bx+2]
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short loc_9D0
		retn	2
; ---------------------------------------------------------------------------

loc_9D0:
		mov	ax, 0FFFEh
		retn	2
sub_9BE		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

sub_9D6		proc near
		push	si
		push	di
		mov	ax, offset aAbnormalProgra ; "Abnormal program termination\r\n"
		push	ax		; buf
		call	___ErrorMessage
		mov	ax, 3
		push	ax		; status
		call	__exit
; ---------------------------------------------------------------------------
		pop	cx
		pop	cx
		pop	di
		pop	si
		retn
sub_9D6		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl atexit(void (*func)(void))
_atexit		proc near

func		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		cmp	word_1898, 20h
		jnz	short loc_9FC
		mov	ax, 1
		jmp	short loc_A0F
; ---------------------------------------------------------------------------

loc_9FC:
		mov	bx, word_1898
		add	bx, bx
		mov	ax, [bp+func]
		mov	[bx+1ABAh], ax
		inc	word_1898
		xor	ax, ax

loc_A0F:
		pop	di
		pop	si
		pop	bp
		retn
_atexit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl __ErrorMessage(char *buf)
___ErrorMessage	proc near

buf		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+buf]	; s
		call	_strlen
		pop	cx
		push	ax		; len
		push	[bp+buf]	; buf
		mov	al, stru_18C0.fd
		cbw
		push	ax		; handle
		call	__rtl_write
		add	sp, 6
		pop	di
		pop	si
		pop	bp
		retn
___ErrorMessage	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_A32		proc near
		push	si
		push	di
		pop	di
		pop	si
		retn
sub_A32		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

sub_A37		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		cmp	[bp+arg_4], 0
		jnz	short loc_A60
		jmp	short loc_A52
; ---------------------------------------------------------------------------

loc_A44:
		dec	word_1898
		mov	bx, word_1898
		add	bx, bx
		call	word_1ABA[bx]

loc_A52:
		cmp	word_1898, 0
		jnz	short loc_A44
		call	__cleanup
		call	off_189A

loc_A60:
		call	__restorezero
		call	__checknull
		cmp	[bp+arg_2], 0
		jnz	short loc_A81
		cmp	[bp+arg_4], 0
		jnz	short loc_A7A
		call	off_189C
		call	off_189E

loc_A7A:
		push	[bp+arg_0]
		call	__terminate
; ---------------------------------------------------------------------------
		pop	cx

loc_A81:
		pop	di
		pop	si
		pop	bp
		retn	6
sub_A37		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn	bp-based frame

; void __cdecl exit(int	status)
_exit		proc near

status		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		xor	ax, ax
		push	ax
		push	ax
		push	[bp+status]
		call	sub_A37
		pop	di
		pop	si
		pop	bp
		retn
_exit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn	bp-based frame

; void __cdecl _exit(int status)
__exit		proc near

status		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, 1
		push	ax
		xor	ax, ax
		push	ax
		push	[bp+status]
		call	sub_A37
		pop	di
		pop	si
		pop	bp
		retn
__exit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void _cexit(void)
__cexit		proc near
		push	si
		push	di
		xor	ax, ax
		push	ax
		mov	ax, 1
		push	ax
		xor	ax, ax
		push	ax
		call	sub_A37
		pop	di
		pop	si
		retn
__cexit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void _c_exit(void)
__c_exit	proc near
		push	si
		push	di
		mov	ax, 1
		push	ax
		push	ax
		xor	ax, ax
		push	ax
		call	sub_A37
		pop	di
		pop	si
		retn
__c_exit	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

__IOERROR	proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	dx, [bp+arg_0]
		or	dx, dx
		jl	short loc_AF5
		cmp	dx, 58h
		jle	short loc_AE6

loc_AE3:
		mov	dx, 57h

loc_AE6:
		mov	word_1A0C, dx
		mov	bx, dx
		mov	al, byte_1A0E[bx]
		cbw
		mov	dx, ax
		jmp	short loc_B03
; ---------------------------------------------------------------------------

loc_AF5:
		neg	dx
		cmp	dx, word_1A84
		jg	short loc_AE3
		mov	word_1A0C, 0FFFFh

loc_B03:
		mov	word_16AA, dx
		mov	ax, 0FFFFh
		pop	di
		pop	si
		pop	bp
		retn	2
__IOERROR	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

__DOSERROR	proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+arg_0]
		call	__IOERROR
		mov	ax, [bp+arg_0]
		pop	di
		pop	si
		pop	bp
		retn	2
__DOSERROR	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl isatty(int handle)
_isatty		proc near

handle		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, 4400h
		mov	bx, [bp+handle]
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		xchg	ax, dx
		and	ax, 80h
		pop	di
		pop	si
		pop	bp
		retn
_isatty		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; __int32 __cdecl lseek(int handle, __int32 offset, int	fromwhere)
_lseek		proc near

handle		= word ptr  4
_offset		= word ptr  6
arg_4		= word ptr  8
fromwhere	= byte ptr  0Ah

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	bx, [bp+handle]
		add	bx, bx
		and	word_19E2[bx], 0FDFFh
		mov	ah, 42h
		mov	al, [bp+fromwhere]
		mov	bx, [bp+handle]
		mov	cx, [bp+arg_4]
		mov	dx, [bp+_offset]
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method:
					; 0-from beginnig,1-from current,2-from	end
		jb	short loc_B5D
		jmp	short loc_B62
; ---------------------------------------------------------------------------

loc_B5D:
		push	ax
		call	__IOERROR
		cwd

loc_B62:
		pop	di
		pop	si
		pop	bp
		retn
_lseek		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

N_SCOPY@	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	ds
		lds	si, [bp+arg_0]
		les	di, [bp+arg_4]
		cld
		shr	cx, 1
		rep movsw
		adc	cx, cx
		rep movsb
		pop	ds
		pop	di
		pop	si
		pop	bp
		retn	8
N_SCOPY@	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

__setupio	proc near
		push	si
		push	di
		mov	dx, 5
		jmp	short loc_BAE
; ---------------------------------------------------------------------------

loc_B89:
		mov	bx, dx
		add	bx, bx
		mov	word_19E2[bx], 0
		mov	bx, dx
		mov	cl, 4
		shl	bx, cl
		mov	stru_18A0.fd[bx], 0FFh
		mov	ax, dx
		shl	ax, cl
		add	ax, offset stru_18A0
		mov	bx, dx
		shl	bx, cl
		mov	stru_18A0.token[bx], ax
		inc	dx

loc_BAE:
		cmp	dx, word_19E0
		jb	short loc_B89
		mov	al, stru_18A0.fd
		cbw
		push	ax		; handle
		call	_isatty
		pop	cx
		or	ax, ax
		jnz	short loc_BC7
		and	stru_18A0.flags, 0FDFFh

loc_BC7:
		mov	ax, 200h
		push	ax		; size
		test	byte ptr stru_18A0.flags+1, 2
		jz	short loc_BD7
		mov	ax, 1
		jmp	short loc_BD9
; ---------------------------------------------------------------------------

loc_BD7:
		xor	ax, ax

loc_BD9:
		push	ax		; type
		xor	ax, ax
		push	ax		; buf
		mov	ax, offset stru_18A0
		push	ax		; stream
		call	_setvbuf
		add	sp, 8
		mov	al, stru_18B0.fd
		cbw
		push	ax		; handle
		call	_isatty
		pop	cx
		or	ax, ax
		jnz	short loc_BFA
		and	stru_18B0.flags, 0FDFFh

loc_BFA:
		mov	ax, 200h
		push	ax		; size
		test	byte ptr stru_18B0.flags+1, 2
		jz	short loc_C0A
		mov	ax, 2
		jmp	short loc_C0C
; ---------------------------------------------------------------------------

loc_C0A:
		xor	ax, ax

loc_C0C:
		push	ax		; type
		xor	ax, ax
		push	ax		; buf
		mov	ax, offset stru_18B0
		push	ax		; stream
		call	_setvbuf
		add	sp, 8
		pop	di
		pop	si
		retn
__setupio	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

___brk		proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, [bp+arg_0]
		mov	dx, sp
		sub	dx, 200h
		cmp	ax, dx
		jnb	short loc_C36
		mov	off_16B0, ax
		xor	ax, ax
		jmp	short loc_C3F
; ---------------------------------------------------------------------------

loc_C36:
		mov	word_16AA, 8
		mov	ax, 0FFFFh

loc_C3F:
		pop	di
		pop	si
		pop	bp
		retn
___brk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

___sbrk		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, [bp+arg_0]
		mov	dx, [bp+arg_2]
		add	ax, off_16B0
		adc	dx, 0
		mov	cx, ax
		or	dx, dx
		jnz	short loc_C6B
		add	cx, 200h
		jb	short loc_C6B
		cmp	cx, sp
		jnb	short loc_C6B
		xchg	ax, off_16B0
		jmp	short loc_C74
; ---------------------------------------------------------------------------

loc_C6B:
		mov	word_16AA, 8
		mov	ax, 0FFFFh

loc_C74:
		pop	di
		pop	si
		pop	bp
		retn
___sbrk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl brk(void *addr)
_brk		proc near

addr		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+addr]
		call	___brk
		pop	cx
		pop	di
		pop	si
		pop	bp
		retn
_brk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; void *__cdecl	sbrk(int incr)
_sbrk		proc near

incr		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, [bp+incr]
		cwd
		push	dx
		push	ax
		call	___sbrk
		pop	cx
		pop	cx
		pop	di
		pop	si
		pop	bp
		retn
_sbrk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void __cdecl free(void *block)
_free		proc near

block		= word ptr  2

		push	si
		push	di
		mov	si, sp
		mov	bx, [si+6]
		sub	bx, 4
		jb	short loc_CB6
		cmp	bx, word_1A6C
		jz	short loc_CB3
		call	sub_CF3
		jmp	short loc_CB6
; ---------------------------------------------------------------------------

loc_CB3:
		call	sub_CB9

loc_CB6:
		pop	di
		pop	si
		retn
_free		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_CB9		proc near
		cmp	word_1A6A, bx
		jz	short loc_CE2
		mov	si, [bx+2]
		test	byte ptr [si], 1
		jz	short loc_CCD
		mov	word_1A6C, si
		jmp	short loc_CED
; ---------------------------------------------------------------------------

loc_CCD:
		cmp	si, word_1A6A
		jz	short loc_CE0
		mov	bx, si
		call	sub_D2C
		mov	ax, [bx+2]
		mov	word_1A6C, ax
		jmp	short loc_CED
; ---------------------------------------------------------------------------

loc_CE0:
		mov	bx, si

loc_CE2:
		xor	ax, ax
		mov	word_1A6A, ax
		mov	word_1A6C, ax
		mov	word_1A6E, ax

loc_CED:
		push	bx
		call	___brk
		pop	bx
		retn
sub_CB9		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_CF3		proc near
		dec	word ptr [bx]
		cmp	bx, word_1A6A
		jz	short loc_D13
		mov	si, [bx+2]
		mov	ax, [si]
		test	al, 1
		jnz	short loc_D13
		add	ax, [bx]
		mov	[si], ax
		mov	di, [bx]
		add	di, bx
		mov	[di+2],	si
		mov	bx, si
		jmp	short loc_D16
; ---------------------------------------------------------------------------

loc_D13:
		call	sub_D48

loc_D16:
		mov	di, [bx]
		add	di, bx
		mov	ax, [di]
		test	al, 1
		jz	short loc_D21
		retn
; ---------------------------------------------------------------------------

loc_D21:
		add	[bx], ax
		mov	si, di
		add	si, ax
		mov	[si+2],	bx
		mov	bx, di
sub_CF3		endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_D2C		proc near
		mov	di, [bx+6]
		cmp	bx, di
		jz	short loc_D41
		mov	word_1A6E, di
		mov	si, [bx+4]
		mov	[di+4],	si
		mov	[si+6],	di
		retn
; ---------------------------------------------------------------------------

loc_D41:
		mov	word_1A6E, 0
		retn
sub_D2C		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_D48		proc near
		mov	si, word_1A6E
		or	si, si
		jz	short loc_D60
		mov	di, [si+6]
		mov	[si+6],	bx
		mov	[di+4],	bx
		mov	[bx+6],	di
		mov	[bx+4],	si
		retn
; ---------------------------------------------------------------------------

loc_D60:
		mov	word_1A6E, bx
		mov	[bx+4],	bx
		mov	[bx+6],	bx
		retn
sub_D48		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void *__cdecl	malloc(size_t size)
_malloc		proc near

_size		= word ptr  2

		push	si
		push	di
		mov	si, sp
		mov	ax, [si+6]
		or	ax, ax
		jz	short loc_DC8
		add	ax, 5
		jb	short loc_DB1
		and	ax, 0FFFEh
		cmp	ax, 8
		jnb	short loc_D86
		mov	ax, 8

loc_D86:
		cmp	word_1A6A, 0
		jz	short loc_DAC
		mov	bx, word_1A6E
		or	bx, bx
		jz	short loc_DA2
		mov	dx, bx

loc_D97:
		cmp	[bx], ax
		jnb	short loc_DB5
		mov	bx, [bx+6]
		cmp	bx, dx
		jnz	short loc_D97

loc_DA2:
		call	sub_E0B
		jmp	short loc_DC8
; ---------------------------------------------------------------------------

loc_DA7:
		call	sub_E34
		jmp	short loc_DC8
; ---------------------------------------------------------------------------

loc_DAC:
		call	sub_DCB
		jmp	short loc_DC8
; ---------------------------------------------------------------------------

loc_DB1:
		xor	ax, ax
		jmp	short loc_DC8
; ---------------------------------------------------------------------------

loc_DB5:
		mov	si, ax
		add	si, 8
		cmp	[bx], si
		jnb	short loc_DA7
		call	sub_D2C
		inc	word ptr [bx]
		mov	ax, bx
		add	ax, 4

loc_DC8:
		pop	di
		pop	si
		retn
_malloc		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_DCB		proc near
		push	ax
		xor	ax, ax
		push	ax
		push	ax
		call	___sbrk
		pop	bx
		pop	bx
		and	ax, 1
		jz	short loc_DE3
		xor	dx, dx
		push	dx
		push	ax
		call	___sbrk
		pop	bx
		pop	bx

loc_DE3:
		pop	ax
		push	ax
		xor	bx, bx
		push	bx
		push	ax
		call	___sbrk
		pop	bx
		pop	bx
		cmp	ax, 0FFFFh
		jz	short loc_E07
		mov	bx, ax
		mov	word_1A6A, bx
		mov	word_1A6C, bx
		pop	ax
		inc	ax
		mov	[bx], ax
		add	bx, 4
		mov	ax, bx
		retn
; ---------------------------------------------------------------------------

loc_E07:
		pop	bx
		xor	ax, ax
		retn
sub_DCB		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_E0B		proc near
		push	ax
		xor	bx, bx
		push	bx
		push	ax
		call	___sbrk
		pop	bx
		pop	bx
		cmp	ax, 0FFFFh
		jz	short loc_E30
		mov	bx, ax
		mov	ax, word_1A6C
		mov	[bx+2],	ax
		mov	word_1A6C, bx
		pop	ax
		inc	ax
		mov	[bx], ax
		add	bx, 4
		mov	ax, bx
		retn
; ---------------------------------------------------------------------------

loc_E30:
		pop	ax
		xor	ax, ax
		retn
sub_E0B		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_E34		proc near
		sub	[bx], ax
		mov	si, bx
		add	si, [bx]
		mov	di, si
		add	di, ax
		inc	ax
		mov	[si], ax
		mov	[si+2],	bx
		mov	[di+2],	si
		add	si, 4
		mov	ax, si
		retn
sub_E34		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __fastcall sub_E4D(size_t	size)
sub_E4D		proc near

var_2		= word ptr -2

		mov	bp, sp
		push	bx
		push	ax
		push	cx
		push	ax		; size
		call	_malloc
		pop	bx
		mov	bx, ax
		or	ax, ax
		jz	short loc_E7C
		push	ds
		pop	es
		assume es:seg000
		cld
		mov	di, ax
		mov	si, [bp+var_2]
		mov	cx, [si]
		add	si, 4
		push	si		; block
		sub	cx, 5
		shr	cx, 1
		rep movsw
		mov	[bp+var_2], ax
		call	_free
		pop	bx
		mov	bx, [bp+var_2]

loc_E7C:
		add	sp, 6
		retn
sub_E4D		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_E80		proc near
		mov	ax, dx
		add	dx, 8
		cmp	dx, cx
		ja	short loc_EBE
		mov	dx, cx
		cmp	bx, word_1A6C
		jnz	short loc_EA0
		mov	[bx], ax
		inc	word ptr [bx]
		add	ax, bx
		push	bx
		push	ax
		call	___brk
		pop	bx
		pop	bx
		jmp	short loc_EBE
; ---------------------------------------------------------------------------

loc_EA0:
		mov	di, bx
		add	di, ax
		mov	[di+2],	bx
		sub	dx, ax
		sub	[bx], dx
		mov	si, di
		add	si, dx
		mov	[si+2],	di
		inc	dx
		mov	[di], dx
		mov	cx, bx
		mov	bx, di
		call	sub_CF3
		mov	bx, cx

loc_EBE:
		add	bx, 4
		retn
sub_E80		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; void *__cdecl	realloc(void *block, size_t size)
_realloc	proc near

block		= word ptr  8
_size		= word ptr  0Ah

		push	si
		push	di
		push	bp
		mov	bp, sp
		mov	bx, [bp+block]
		mov	ax, [bp+_size]
		or	ax, ax
		jz	short loc_F08
		or	bx, bx
		jz	short loc_F02
		sub	bx, 4
		mov	cx, [bx]
		dec	cx
		mov	dx, ax
		add	dx, 5
		and	dx, 0FFFEh
		cmp	dx, 8
		jnb	short loc_EEB
		mov	dx, 8

loc_EEB:
		cmp	cx, dx
		jb	short loc_EFB
		ja	short loc_EF6
		add	bx, 4
		jmp	short loc_EFE
; ---------------------------------------------------------------------------

loc_EF6:
		call	sub_E80
		jmp	short loc_EFE
; ---------------------------------------------------------------------------

loc_EFB:
		call	sub_E4D

loc_EFE:
		mov	ax, bx
		jmp	short loc_F0F
; ---------------------------------------------------------------------------

loc_F02:
		push	ax		; size
		call	_malloc
		jmp	short loc_F0E
; ---------------------------------------------------------------------------

loc_F08:
		push	bx		; block
		call	_free
		xor	ax, ax

loc_F0E:
		pop	bx

loc_F0F:
		pop	bp
		pop	di
		pop	si
		retn
_realloc	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_F13		proc near
		push	ax
		push	cx
		push	dx
		push	bx
		push	sp
		push	bp
		push	si
		push	di
		push	ds
		push	es
		mov	bp, sp
		mov	ax, word ptr dword_1A70
		or	ax, word ptr dword_1A70+2
		jnz	short loc_F4E
		mov	si, 0FFFFh
		push	ds
		mov	ax, 6300h
		clc
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		mov	ax, ds
		pop	ds
		jb	short loc_F42
		mov	dx, ds
		cmp	ax, dx
		jz	short loc_F42
		cmp	si, 0FFFFh
		jnz	short loc_F47

loc_F42:
		mov	si, offset unk_1A74
		mov	ax, ds

loc_F47:
		mov	word ptr dword_1A70, si
		mov	word ptr dword_1A70+2, ax

loc_F4E:
		mov	sp, bp
		pop	es
		assume es:nothing
		pop	ds
		pop	di
		pop	si
		pop	bp
		pop	bx
		pop	bx
		pop	dx
		pop	cx
		pop	ax
		retn
sub_F13		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_F5B		proc near

arg_0		= byte ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	al, [bp+arg_0]
		xor	cx, cx
		les	bx, dword_1A70

loc_F69:
		mov	dx, es:[bx]
		or	dx, dx
		jz	short loc_F7B
		cmp	al, dl
		jb	short loc_F7B
		inc	bx
		inc	bx
		cmp	al, dh
		ja	short loc_F69
		inc	cx

loc_F7B:
		xchg	ax, cx
		pop	di
		pop	si
		pop	bp
		retn
sub_F5B		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_F80		proc near

var_2		= word ptr -2
arg_0		= word ptr  4
arg_2		= word ptr  6

		push	bp
		mov	bp, sp
		sub	sp, 2
		push	si
		push	di
		xor	dx, dx
		mov	ax, [bp+arg_0]
		mov	[bp+var_2], ax

loc_F90:
		mov	bx, [bp+var_2]
		cmp	byte ptr [bx], 0
		jnz	short loc_F9C
		xor	dx, dx
		jmp	short loc_FC7
; ---------------------------------------------------------------------------

loc_F9C:
		cmp	dx, 1
		jnz	short loc_FA6
		mov	dx, 2
		jmp	short loc_FBA
; ---------------------------------------------------------------------------

loc_FA6:
		mov	bx, [bp+var_2]
		push	word ptr [bx]
		call	sub_F5B
		pop	cx
		or	ax, ax
		jz	short loc_FB8
		mov	dx, 1
		jmp	short loc_FBA
; ---------------------------------------------------------------------------

loc_FB8:
		xor	dx, dx

loc_FBA:
		mov	ax, [bp+var_2]
		cmp	ax, [bp+arg_2]
		jnb	short loc_FC7
		inc	[bp+var_2]
		jmp	short loc_F90
; ---------------------------------------------------------------------------

loc_FC7:
		or	dx, dx
		jnz	short loc_FD0
		mov	ax, 1
		jmp	short loc_FD2
; ---------------------------------------------------------------------------

loc_FD0:
		xor	ax, ax

loc_FD2:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
sub_F80		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl fflush(FILE *stream)
_fflush		proc near

var_2		= word ptr -2
stream		= word ptr  4

		push	bp
		mov	bp, sp
		sub	sp, 2
		push	si
		push	di
		cmp	[bp+stream], 0
		jnz	short loc_FEB
		call	_flushall
		jmp	short loc_1061
; ---------------------------------------------------------------------------

loc_FEB:
		mov	bx, [bp+stream]
		mov	ax, [bx+0Eh]
		cmp	ax, [bp+stream]
		jnz	short loc_105C
		mov	bx, [bp+stream]
		cmp	word ptr [bx], 0
		jl	short loc_1029
		test	byte ptr [bx+2], 8
		jnz	short loc_100F
		mov	ax, [bp+stream]
		add	ax, 5
		cmp	[bx+0Ah], ax
		jnz	short loc_1061

loc_100F:
		mov	bx, [bp+stream]
		mov	word ptr [bx], 0
		mov	ax, [bp+stream]
		add	ax, 5
		cmp	[bx+0Ah], ax
		jnz	short loc_1061
		mov	ax, [bx+8]
		mov	[bx+0Ah], ax
		jmp	short loc_1061
; ---------------------------------------------------------------------------

loc_1029:
		mov	bx, [bp+stream]
		mov	ax, [bx+6]
		add	ax, [bx]
		inc	ax
		mov	[bp+var_2], ax
		sub	[bx], ax
		push	ax		; len
		mov	ax, [bx+8]
		mov	[bx+0Ah], ax
		push	ax		; buf
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	___write
		add	sp, 6
		cmp	ax, [bp+var_2]
		jz	short loc_1061
		mov	bx, [bp+stream]
		test	byte ptr [bx+3], 2
		jnz	short loc_1061
		or	word ptr [bx+2], 10h

loc_105C:
		mov	ax, 0FFFFh
		jmp	short loc_1063
; ---------------------------------------------------------------------------

loc_1061:
		xor	ax, ax

loc_1063:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
_fflush		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int flushall(void)
_flushall	proc near

var_6		= word ptr -6
var_4		= word ptr -4
stream		= word ptr -2

		push	bp
		mov	bp, sp
		sub	sp, 6
		push	si
		push	di
		mov	[bp+var_6], 0
		mov	ax, word_19E0
		mov	[bp+var_4], ax
		mov	[bp+stream], offset stru_18A0
		jmp	short loc_1098
; ---------------------------------------------------------------------------

loc_1083:
		mov	bx, [bp+stream]
		test	byte ptr [bx+2], 3
		jz	short loc_1094
		push	bx		; stream
		call	_fflush
		pop	cx
		inc	[bp+var_6]

loc_1094:
		add	[bp+stream], 10h

loc_1098:
		mov	ax, [bp+var_4]
		dec	[bp+var_4]
		or	ax, ax
		jnz	short loc_1083
		mov	ax, [bp+var_6]
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
_flushall	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

sub_10AB	proc near

var_2		= word ptr -2
arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		sub	sp, 2
		push	si
		push	di
		mov	bx, [bp+arg_0]
		cmp	word ptr [bx], 0
		jge	short loc_10C5
		mov	dx, [bx+6]
		add	dx, [bx]
		inc	dx
		mov	ax, dx
		jmp	short loc_10D1
; ---------------------------------------------------------------------------

loc_10C5:
		mov	bx, [bp+arg_0]
		mov	ax, [bx]
		cwd
		xor	ax, dx
		sub	ax, dx
		mov	dx, ax

loc_10D1:
		mov	[bp+var_2], ax
		mov	bx, [bp+arg_0]
		test	byte ptr [bx+2], 40h
		jnz	short loc_1110
		mov	bx, [bp+arg_0]
		mov	cx, [bx+0Ah]
		cmp	word ptr [bx], 0
		jge	short loc_1109
		jmp	short loc_10F5
; ---------------------------------------------------------------------------

loc_10EA:
		dec	cx
		mov	bx, cx
		cmp	byte ptr [bx], 0Ah
		jnz	short loc_10F5
		inc	[bp+var_2]

loc_10F5:
		mov	ax, dx
		dec	dx
		or	ax, ax
		jnz	short loc_10EA
		jmp	short loc_1110
; ---------------------------------------------------------------------------

loc_10FE:
		mov	bx, cx
		inc	cx
		cmp	byte ptr [bx], 0Ah
		jnz	short loc_1109
		inc	[bp+var_2]

loc_1109:
		mov	ax, dx
		dec	dx
		or	ax, ax
		jnz	short loc_10FE

loc_1110:
		mov	ax, [bp+var_2]
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn	2
sub_10AB	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl fseek(FILE *stream, __int32 offset, int whence)
_fseek		proc near

stream		= word ptr  4
_offset		= dword	ptr  6
whence		= word ptr  0Ah

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+stream]	; stream
		call	_fflush
		pop	cx
		or	ax, ax
		jz	short loc_1130
		mov	ax, 0FFFFh
		jmp	short loc_1180
; ---------------------------------------------------------------------------

loc_1130:
		cmp	[bp+whence], 1
		jnz	short loc_1149
		mov	bx, [bp+stream]
		cmp	word ptr [bx], 0
		jle	short loc_1149
		push	bx
		call	sub_10AB
		cwd
		sub	word ptr [bp+_offset], ax
		sbb	word ptr [bp+_offset+2],	dx

loc_1149:
		mov	bx, [bp+stream]
		and	word ptr [bx+2], 0FE5Fh
		mov	word ptr [bx], 0
		mov	ax, [bx+8]
		mov	[bx+0Ah], ax
		push	[bp+whence]	; fromwhere
		push	word ptr [bp+_offset+2]
		push	word ptr [bp+_offset] ; offset
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		cmp	dx, 0FFFFh
		jnz	short loc_117E
		cmp	ax, 0FFFFh
		jnz	short loc_117E
		mov	ax, 0FFFFh
		jmp	short loc_1180
; ---------------------------------------------------------------------------

loc_117E:
		xor	ax, ax

loc_1180:
		pop	di
		pop	si
		pop	bp
		retn
_fseek		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; __int32 __cdecl ftell(FILE *stream)
_ftell		proc near

var_8		= word ptr -8
var_6		= word ptr -6
_offset		= dword	ptr -4
stream		= word ptr  4

		push	bp
		mov	bp, sp
		sub	sp, 8
		push	si
		push	di
		mov	ax, 1
		push	ax		; fromwhere
		xor	ax, ax
		push	ax
		push	ax		; offset
		mov	bx, [bp+stream]
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		mov	word ptr [bp+_offset+2],	dx
		mov	word ptr [bp+_offset], ax
		cmp	dx, 0FFFFh
		jnz	short loc_11B5
		cmp	ax, 0FFFFh
		jnz	short loc_11B5
		jmp	loc_1245
; ---------------------------------------------------------------------------

loc_11B5:
		mov	bx, [bp+stream]
		cmp	word ptr [bx], 0
		jge	short loc_1238
		mov	al, [bx+4]
		cbw
		add	ax, ax
		mov	bx, ax
		test	byte ptr (word_19E2+1)[bx], 8
		jz	short loc_1229
		mov	ax, 2
		push	ax		; fromwhere
		xor	ax, ax
		push	ax
		push	ax		; offset
		mov	bx, [bp+stream]
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		mov	[bp+var_6], dx
		mov	[bp+var_8], ax
		cmp	dx, 0FFFFh
		jnz	short loc_11F4
		cmp	ax, 0FFFFh
		jnz	short loc_11F4
		jmp	short loc_124B
; ---------------------------------------------------------------------------

loc_11F4:
		xor	ax, ax
		push	ax		; fromwhere
		push	word ptr [bp+_offset+2]
		push	word ptr [bp+_offset] ; offset
		mov	bx, [bp+stream]
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		cmp	dx, 0FFFFh
		jnz	short loc_121D
		cmp	ax, 0FFFFh
		jnz	short loc_121D
		mov	dx, 0FFFFh
		mov	ax, 0FFFFh
		jmp	short loc_124B
; ---------------------------------------------------------------------------

loc_121D:
		mov	dx, [bp+var_6]
		mov	ax, [bp+var_8]
		mov	word ptr [bp+_offset+2],	dx
		mov	word ptr [bp+_offset], ax

loc_1229:
		push	[bp+stream]
		call	sub_10AB
		cwd
		add	word ptr [bp+_offset], ax
		adc	word ptr [bp+_offset+2],	dx
		jmp	short loc_1245
; ---------------------------------------------------------------------------

loc_1238:
		push	[bp+stream]
		call	sub_10AB
		cwd
		sub	word ptr [bp+_offset], ax
		sbb	word ptr [bp+_offset+2],	dx

loc_1245:
		mov	dx, word ptr [bp+_offset+2]
		mov	ax, word ptr [bp+_offset]

loc_124B:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
_ftell		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl setvbuf(FILE *stream, char *buf, int type, size_t	size)
_setvbuf	proc near

stream		= word ptr  4
buf		= word ptr  6
_type		= word ptr  8
_size		= word ptr  0Ah

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	bx, [bp+stream]
		mov	ax, [bx+0Eh]
		cmp	ax, [bp+stream]
		jz	short loc_1264
		jmp	loc_130F
; ---------------------------------------------------------------------------

loc_1264:
		cmp	[bp+_type], 2
		jle	short loc_126D
		jmp	loc_130F
; ---------------------------------------------------------------------------

loc_126D:
		cmp	[bp+_size], 7FFFh
		jbe	short loc_1277
		jmp	loc_130F
; ---------------------------------------------------------------------------

loc_1277:
		cmp	word_1A82, 0
		jnz	short loc_128D
		cmp	[bp+stream], offset stru_18B0
		jnz	short loc_128D
		mov	word_1A82, 1
		jmp	short loc_12A1
; ---------------------------------------------------------------------------

loc_128D:
		cmp	word_1A80, 0
		jnz	short loc_12A1
		cmp	[bp+stream], offset stru_18A0
		jnz	short loc_12A1
		mov	word_1A80, 1

loc_12A1:
		mov	bx, [bp+stream]
		cmp	word ptr [bx], 0
		jz	short loc_12B8
		mov	ax, 1
		push	ax		; whence
		xor	ax, ax
		push	ax
		push	ax		; offset
		push	bx		; stream
		call	_fseek
		add	sp, 8

loc_12B8:
		mov	bx, [bp+stream]
		test	byte ptr [bx+2], 4
		jz	short loc_12C8
		push	word ptr [bx+8]	; block
		call	_free
		pop	cx

loc_12C8:
		mov	bx, [bp+stream]
		and	word ptr [bx+2], 0FFF3h
		mov	word ptr [bx+6], 0
		mov	ax, [bp+stream]
		add	ax, 5
		mov	[bx+8],	ax
		mov	[bx+0Ah], ax
		cmp	[bp+_type], 2
		jz	short loc_1330
		cmp	[bp+_size], 0
		jbe	short loc_1330
		mov	off_189A, offset __xfflush
		cmp	[bp+buf], 0
		jnz	short loc_1314
		push	[bp+_size]	; size
		call	_malloc
		pop	cx
		mov	[bp+buf], ax
		or	ax, ax
		jz	short loc_130F
		mov	bx, [bp+stream]
		or	word ptr [bx+2], 4
		jmp	short loc_1314
; ---------------------------------------------------------------------------

loc_130F:
		mov	ax, 0FFFFh
		jmp	short loc_1332
; ---------------------------------------------------------------------------

loc_1314:
		mov	bx, [bp+stream]
		mov	ax, [bp+buf]
		mov	[bx+0Ah], ax
		mov	[bx+8],	ax
		mov	ax, [bp+_size]
		mov	[bx+6],	ax
		cmp	[bp+_type], 1
		jnz	short loc_1330
		or	word ptr [bx+2], 8

loc_1330:
		xor	ax, ax

loc_1332:
		pop	di
		pop	si
		pop	bp
		retn
_setvbuf	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; size_t __cdecl strlen(const char *s)
_strlen		proc near

s		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, ds
		mov	es, ax
		assume es:seg000
		mov	di, [bp+s]
		xor	ax, ax
		cld
		mov	cx, 0FFFFh
		repne scasb
		xchg	ax, cx
		not	ax
		dec	ax
		pop	di
		pop	si
		pop	bp
		retn
_strlen		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl __write(int handle, void *buf, unsigned int len)
___write	proc near

var_8A		= byte ptr -8Ah
var_8		= word ptr -8
var_5		= byte ptr -5
var_4		= word ptr -4
var_2		= word ptr -2
handle		= word ptr  4
buf		= word ptr  6
len		= word ptr  8

		push	bp
		mov	bp, sp
		sub	sp, 8Ah
		push	si
		push	di
		mov	ax, [bp+handle]
		cmp	ax, word_19E0
		jb	short loc_136E
		mov	ax, 6
		push	ax
		call	__IOERROR
		jmp	loc_1471
; ---------------------------------------------------------------------------

loc_136E:
		mov	ax, [bp+len]
		inc	ax
		cmp	ax, 2
		jnb	short loc_137C
		xor	ax, ax
		jmp	loc_1471
; ---------------------------------------------------------------------------

loc_137C:
		mov	bx, [bp+handle]
		add	bx, bx
		test	byte ptr (word_19E2+1)[bx], 8
		jz	short loc_1399
		mov	ax, 2
		push	ax		; fromwhere
		xor	ax, ax
		push	ax
		push	ax		; offset
		push	[bp+handle]	; handle
		call	_lseek
		add	sp, 8

loc_1399:
		mov	bx, [bp+handle]
		add	bx, bx
		test	byte ptr (word_19E2+1)[bx], 40h
		jnz	short loc_13B7
		push	[bp+len]	; len
		push	[bp+buf]	; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		jmp	loc_1471
; ---------------------------------------------------------------------------

loc_13B7:
		mov	bx, [bp+handle]
		add	bx, bx
		and	word_19E2[bx], 0FDFFh
		mov	ax, [bp+buf]
		mov	[bp+var_8], ax
		mov	ax, [bp+len]
		mov	[bp+var_4], ax
		jmp	short loc_1429
; ---------------------------------------------------------------------------

loc_13D0:
		dec	[bp+var_4]
		mov	bx, [bp+var_8]
		inc	[bp+var_8]
		mov	al, [bx]
		mov	[bp+var_5], al
		cmp	al, 0Ah
		jnz	short loc_13E8
		mov	bx, cx
		mov	byte ptr [bx], 0Dh
		inc	cx

loc_13E8:
		mov	bx, cx
		mov	al, [bp+var_5]
		mov	[bx], al
		inc	cx
		lea	ax, [bp+var_8A]
		mov	dx, cx
		sub	dx, ax
		cmp	dx, 80h
		jl	short loc_142D
		mov	dx, cx
		sub	dx, ax
		mov	[bp+var_2], dx
		push	dx		; len
		push	ax		; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		mov	dx, ax
		cmp	ax, [bp+var_2]
		jz	short loc_1429
		cmp	dx, 0FFFFh
		jnz	short loc_1421
		mov	ax, 0FFFFh
		jmp	short loc_146C
; ---------------------------------------------------------------------------

loc_1421:
		mov	ax, [bp+len]
		sub	ax, [bp+var_4]
		jmp	short loc_1467
; ---------------------------------------------------------------------------

loc_1429:
		lea	cx, [bp+var_8A]

loc_142D:
		cmp	[bp+var_4], 0
		jnz	short loc_13D0
		lea	ax, [bp+var_8A]
		mov	dx, cx
		sub	dx, ax
		mov	[bp+var_2], dx
		mov	ax, dx
		or	ax, ax
		jbe	short loc_146E
		push	dx		; len
		lea	ax, [bp+var_8A]
		push	ax		; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		mov	dx, ax
		cmp	ax, [bp+var_2]
		jz	short loc_146E
		cmp	dx, 0FFFFh
		jnz	short loc_1464
		mov	ax, 0FFFFh
		jmp	short loc_146C
; ---------------------------------------------------------------------------

loc_1464:
		mov	ax, [bp+len]

loc_1467:
		add	ax, dx
		sub	ax, [bp+var_2]

loc_146C:
		jmp	short loc_1471
; ---------------------------------------------------------------------------

loc_146E:
		mov	ax, [bp+len]

loc_1471:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
___write	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl _rtl_write(int handle, const void	*buf, unsigned int len)
__rtl_write	proc near

handle		= word ptr  4
buf		= word ptr  6
len		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	bx, [bp+handle]
		add	bx, bx
		test	byte ptr word_19E2[bx],	1
		jz	short loc_148E
		mov	ax, 5
		push	ax
		jmp	short loc_14AD
; ---------------------------------------------------------------------------

loc_148E:
		mov	ah, 40h
		mov	bx, [bp+handle]
		mov	cx, [bp+len]
		mov	dx, [bp+buf]
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		jb	short loc_14AC
		push	ax
		mov	bx, [bp+handle]
		add	bx, bx
		or	word_19E2[bx], 1000h
		pop	ax
		jmp	short loc_14B0
; ---------------------------------------------------------------------------

loc_14AC:
		push	ax

loc_14AD:
		call	__IOERROR

loc_14B0:
		pop	di
		pop	si
		pop	bp
		retn
__rtl_write	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl _write(int handle, const void *buf, unsigned int len)
__write		proc near

handle		= word ptr  4
buf		= word ptr  6
len		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+len]	; len
		push	[bp+buf]	; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		pop	di
		pop	si
		pop	bp
		retn
__write		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

__xfflush	proc near

var_4		= word ptr -4
stream		= word ptr -2

		push	bp
		mov	bp, sp
		sub	sp, 4
		push	si
		push	di
		mov	[bp+var_4], 4
		mov	[bp+stream], offset stru_18A0
		jmp	short loc_14F5
; ---------------------------------------------------------------------------

loc_14E0:
		mov	bx, [bp+stream]
		test	byte ptr [bx+2], 3
		jz	short loc_14EE
		push	bx		; stream
		call	_fflush
		pop	cx

loc_14EE:
		dec	[bp+var_4]
		add	[bp+stream], 10h

loc_14F5:
		cmp	[bp+var_4], 0
		jnz	short loc_14E0
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
__xfflush	endp

; ---------------------------------------------------------------------------
word_1501	dw 0

; =============== S U B	R O U T	I N E =======================================

; BCC v4.x/5.x DOS runtime
; Attributes: library function

unknown_libname_1 proc near

; FUNCTION CHUNK AT 15E9 SIZE 00000059 BYTES

		pop	word_1A8A
		pop	word_1A8C
		pop	word_1A8E
		mov	cs:word_1501, ds
		mov	word_1A90, si
		mov	word_1A92, di
		cld
		mov	es, word_16A6
		assume es:nothing
		mov	si, 80h
		xor	ah, ah
		lods	byte ptr es:[si]
		inc	ax
		mov	bp, es
		xchg	dx, si
		xchg	ax, bx
		mov	si, word_16A0
		inc	si
		inc	si
		mov	cx, 1
		cmp	byte ptr word_16A8, 3
		jb	short loc_154F
		mov	es, word_16A2
		mov	di, si
		mov	cl, 7Fh
		xor	al, al
		repne scasb
		jcxz	short loc_1596
		xor	cl, 7Fh

loc_154F:
		push	ax
		mov	ax, cx
		add	ax, bx
		inc	ax
		and	ax, 0FFFEh
		mov	di, sp
		sub	di, ax
		jb	short loc_1596
		mov	sp, di
		push	es
		pop	ds
		push	ss
		pop	es
		push	cx
		dec	cx
		rep movsb
		xor	al, al
		stosb
		mov	ds, bp
		xchg	si, dx
		xchg	bx, cx
		mov	ax, bx
		mov	dx, ax
		inc	bx

loc_1576:
		call	sub_1599
		ja	short loc_1586

loc_157B:
		jb	short loc_15E9
		cmp	al, 0Dh
		jz	short loc_1592
		call	sub_1599
		ja	short loc_157B

loc_1586:
		cmp	al, 20h
		jz	short loc_1592
		cmp	al, 0Dh
		jz	short loc_1592
		cmp	al, 9
		jnz	short loc_1576

loc_1592:
		xor	al, al
		jmp	short loc_1576
; ---------------------------------------------------------------------------

loc_1596:
		jmp	sub_9D6
unknown_libname_1 endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================


sub_1599	proc near
		or	ax, ax
		jz	short loc_15A4
		inc	dx
		stosb
		or	al, al
		jnz	short loc_15A4
		inc	bx

loc_15A4:
		xchg	ah, al
		xor	al, al
		stc
		jcxz	short locret_15E8
		lodsb
		dec	cx
		cmp	dh, 1
		jz	short loc_15CE
		xor	dh, dh
		push	ax
		push	bx
		push	cx
		push	dx
		push	ds
		push	es
		mov	ds, cs:word_1501
		push	ax
		call	sub_F5B
		or	ax, ax
		pop	cx
		pop	es
		pop	ds
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jz	short loc_15D0

loc_15CE:
		inc	dh

loc_15D0:
		cmp	dh, 0
		jnz	short loc_15E6
		sub	al, 22h
		jz	short locret_15E8
		add	al, 22h
		cmp	al, 5Ch
		jnz	short loc_15E6
		cmp	byte ptr [si], 22h
		jnz	short loc_15E6
		lodsb
		dec	cx

loc_15E6:
		or	si, si

locret_15E8:
		retn
sub_1599	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR unknown_libname_1

loc_15E9:
		pop	cx
		xor	dh, dh
		add	cx, dx
		mov	ds, cs:word_1501
		mov	word_1A86, bx
		inc	bx
		add	bx, bx
		mov	si, sp
		mov	bp, sp
		sub	bp, bx
		jb	short loc_1596
		mov	sp, bp
		mov	word_1A88, bp

loc_1608:
		jcxz	short loc_1618
		mov	[bp+0],	si
		add	bp, 2

loc_1610:
		lods	byte ptr ss:[si]
		or	al, al
		loopne	loc_1610
		jz	short loc_1608

loc_1618:
		xor	ax, ax
		mov	[bp+0],	ax
		mov	ds, cs:word_1501
		mov	si, word_1A90
		mov	di, word_1A92
		push	word_1A8E
		push	word_1A8C
		mov	ax, word_1A86
		mov	argc, ax
		mov	ax, word_1A88
		mov	argv, ax
		jmp	word_1A8A
; END OF FUNCTION CHUNK	FOR unknown_libname_1
; ---------------------------------------------------------------------------
		db 14 dup(0)
aBorlandCCopyri	db 'Borland C++ - Copyright 1993 Borland Intl.',0
aDivideError	db 'Divide error',0Dh,0Ah,0
dword_168A	dd 0
dword_168E	dd 0
dword_1692	dd 0
dword_1696	dd 0
; int argc
argc		dw 0
; char **argv
argv		dw 0
; char **envp
envp		dw 0
word_16A0	dw 0
word_16A2	dw 0
word_16A4	dw 0
word_16A6	dw 0
word_16A8	dw 0
word_16AA	dw 0
		dw 0FFFFh
		dw offset edata@
off_16B0	dw offset edata@
		db 0
		db    0
word_16B4	dw 0
		db 0
		db    0
word_16B8	dw 0
		db 0
		db    0
word_16BC	dw 0
byte_16BE	db 0
unk_16BF	db 0FFh
		db    3
		db    3
		db    1
		db    1
		db    1
aMiko_cfg	db 'miko.cfg',0
aKsoconfig	db 'KSOConfig',0
aUmx		db 0Ah
		db 0Ah
		db '東方怪綺談用　 常駐プログラム　                         Version1.00 (c)zun 1998',0Ah,0
aVVVvvVV	db 'まだいませんよぉ',0Ah
		db 0Ah,0
aVVsvqvBBavVIqv	db 'じゃぁねー、また会えるよね',0Ah
		db 0Ah,0
aVV		db 'そんなオプション付けられても、困るんですけど',0Ah
		db 0Ah,0
aVavVBavVVVvvVV	db 'わたし、すでにいますよぉ',0Ah
		db 0Ah,0
aNVVVV		db '作れません、わたしの居場所がないの！',0Ah
		db 0Ah,0
aVivVsvVVBVBb	db 'おじゃましまーす。',0Ah
		db 0Ah,0
aGtg@gcglvkpsvl	db 'ファイルが書き込めないの〜',0Ah
		db 0Ah,0
aMasters_libVer	db 'MASTERS.LIB Version 0.23 Copyright (c)1995 A.Koizuka,Kazumi,steelman,iR,All rights reserved.',0
		db 0
word_185C	dw 0A800h
word_185E	dw 3E80h
		db  90h	; ・
		db    1
		db  50h	; P
		db    0
		db    0
		db    0
		db  55h	; U
		db    0
aPal98Grb	db 'pal98 grb',0
word_1872	dw 0
word_1874	dw 0FFFFh
byte_1876	db 0
		db 0
aAbnormalProgra	db 'Abnormal program termination',0Dh,0Ah,0
		db 0
word_1898	dw 0
off_189A	dw offset sub_A32
off_189C	dw offset sub_A32
off_189E	dw offset sub_A32
stru_18A0	FILE <0, 209h, 0, 0, 0,	0, 0, 0, offset	stru_18A0>
stru_18B0	FILE <0, 20Ah, 1, 0, 0,	0, 0, 0, offset	stru_18B0>
stru_18C0	FILE <0, 202h, 2, 0, 0,	0, 0, 0, offset	stru_18C0>
stru_18D0	FILE <0, 243h, 3, 0, 0,	0, 0, 0, offset	stru_18D0>
stru_18E0	FILE <0, 242h, 4, 0, 0,	0, 0, 0, offset	stru_18E0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
word_19E0	dw 14h
word_19E2	dw 6001h, 6002h, 6002h,	0A004h,	0A002h,	0, 0, 0, 0, 0
		dw 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
word_1A0A	dw 0
word_1A0C	dw 0
byte_1A0E	db 0
		db  13h
		db    2
		db    2
		db    4
		db    5
		db    6
		db    8
		db    8
		db    8
		db  14h
		db  15h
		db    5
		db  13h
		db  0Eh
		db    5
		db    5
		db  11h
		db    2
		db  1Eh
		db  29h	; )
		db  2Ch	; ,
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  29h	; )
		db  2Ch	; ,
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db    5
		db    5
		db  29h	; )
		db  17h
		db  17h
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Fh
		db  2Ch	; ,
		db  23h	; #
		db    2
		db  2Ch	; ,
		db  0Fh
		db  2Ah	; *
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  13h
		db  1Bh
		db  1Ch
		db    2
		db    2
		db    5
		db  0Fh
		db    2
		db  17h
		db  28h	; (
		db  2Ah	; *
		db  13h
		db  2Ah	; *
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  23h	; #
		db  0Eh
		db  1Ch
		db  28h	; (
		db  17h
		db  23h	; #
		db  25h	; %
		db  13h
		db  28h	; (
		db    0
word_1A68	dw 1000h
word_1A6A	dw 0
word_1A6C	dw 0
word_1A6E	dw 0
dword_1A70	dd 0
unk_1A74	db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
word_1A80	dw 0
word_1A82	dw 0
word_1A84	dw 30h
word_1A86	dw 0
word_1A88	dw 0
word_1A8A	dw 0
word_1A8C	dw 0
word_1A8E	dw 0
word_1A90	dw 0
word_1A92	dw 0
InitStart	db 0
		db 2
		dw offset __setupio
		db 0
		db 0
		db    0
		db  0Fh
		dw offset sub_F13
		db    0
		db    0
		db    0
		db  10h
		dw offset unknown_libname_1 ; BCC v4.x/5.x DOS runtime
		dw ?
bdata@		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
unk_1AAA	db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
word_1AAE	dw ?
word_1AB0	dw ?
word_1AB2	dw ?
unk_1AB4	db    ?	;
		db    ?	;
unk_1AB6	db    ?	;
		db    ?	;
unk_1AB8	db    ?	;
		db    ?	;
word_1ABA	dw ?
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
edata@	label byte
seg000		ends


		end start

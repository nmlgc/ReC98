; ---------------------------------------------------------------------------

FILE		struc ;	(sizeof=0x10, standard type)
level		dw ?
flags		dw ?
fd		db ?
hold		db ?
bsize		dw ?
buffer		dw ?			; offset
curp		dw ?			; offset
istemp		dw ?
token		dw ?			; offset (00000000)
FILE		ends


;
; +-------------------------------------------------------------------------+
; |   This file has been generated by The Interactive Disassembler (IDA)    |
; |        Copyright (c) 2009 by Hex-Rays, <support@hex-rays.com>           |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	C84DB5A5C97E54BA50E3BE80D8C24034

; File Name   :	th04/ZUN.COM:RES_HUMA (-S)
; Format      :	MS-DOS COM-file
; Base Address:	0h Range: 100h-19D8h Loaded length: 18D8h
; OS type	  :  MS	DOS
; Application type:  Executable	16bit

		.386
		.model tiny

; ===========================================================================

; Segment type:	Pure code
seg000		segment	byte public 'CODE' use16
		assume cs:seg000
		org 100h
		assume es:nothing, ss:nothing, ds:seg000, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn

		public start
start		proc near
		mov	dx, cs
		mov	cs:DGROUP@, dx
		mov	ah, 30h
		int	21h		; DOS -	GET DOS	VERSION
					; Return: AL = major version number (00h for DOS 1.x)
		mov	bp, ds:2
		mov	bx, ds:2Ch
		mov	ds, dx
		mov	word_15E8, ax
		mov	word_15E6, es
		mov	word_15E2, bx
		mov	word_15FC, bp
		call	sub_26E
		mov	ax, word_15E2
		mov	es, ax
		xor	ax, ax
		mov	bx, ax
		mov	di, ax
		mov	cx, 7FFFh
		cld

loc_136:
		repne scasb
		jcxz	short loc_19B
		inc	bx
		cmp	es:[di], al
		jnz	short loc_136
		or	ch, 80h
		neg	cx
		mov	word_15E0, cx
		mov	cx, 1
		shl	bx, cl
		add	bx, 8
		and	bx, 0FFF8h
		mov	word_15E4, bx
		mov	dx, ds
		sub	bp, dx
		mov	di, word_199C
		cmp	di, 200h
		jnb	short loc_16D
		mov	di, 200h
		mov	word_199C, di

loc_16D:
		add	di, offset edata@
		jb	short loc_19B
		add	di, word_193E
		jb	short loc_19B
		mov	cl, 4
		shr	di, cl
		inc	di
		cmp	bp, di
		jb	short loc_19B
		cmp	word_199C, 0
		jz	short loc_190
		cmp	word_193E, 0
		jnz	short loc_19E

loc_190:
		mov	di, 1000h
		cmp	bp, di
		ja	short loc_19E
		mov	di, bp
		jmp	short loc_19E
; ---------------------------------------------------------------------------

loc_19B:
		call	sub_91C
; ---------------------------------------------------------------------------

loc_19E:
		mov	bx, di
		add	bx, dx
		mov	word_15F4, bx
		mov	word_15F8, bx
		mov	ax, word_15E6
		sub	bx, ax
		mov	es, ax
		mov	ah, 4Ah
		push	di
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		pop	di
		shl	di, cl
		cli
		mov	ss, dx
		mov	sp, di
		sti
		xor	ax, ax
		mov	es, cs:DGROUP@
		mov	di, offset bdata@
		mov	cx, offset edata@
		sub	cx, di
		cld
		rep stosb
		cmp	word_1914, 14h
		jbe	short loc_21F
		cmp	byte ptr word_15E8, 3
		jb	short loc_21F
		ja	short loc_1E8
		cmp	byte ptr word_15E8+1, 1Eh
		jb	short loc_21F

loc_1E8:
		mov	ax, 5801h
		mov	bx, 2
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		jb	short loc_21C
		mov	ah, 67h
		mov	bx, word_1914
		int	21h		; DOS -	3.3+ - SET HANDLE COUNT
					; BX = desired number of handles (max 255)
		jb	short loc_21C
		mov	ah, 48h
		mov	bx, 1
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short loc_21C
		inc	ax
		mov	word_15FC, ax
		dec	ax
		mov	es, ax
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		jb	short loc_21C
		mov	ax, 5801h
		mov	bx, 0
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		jnb	short loc_21F

loc_21C:
		call	sub_91C
; ---------------------------------------------------------------------------

loc_21F:
		xor	bp, bp
		mov	es, cs:DGROUP@
		assume es:nothing
		mov	si, offset InitStart
		mov	di, offset bdata@
		call	sub_2DE
		push	envp		; envp
		push	argv		; argv
		push	argc		; argc
		call	_main
		push	ax		; status
		call	_exit
; ---------------------------------------------------------------------------

__cleanup:
		mov	es, cs:DGROUP@
		push	si
		push	di
		mov	si, offset bdata@
		mov	di, offset bdata@
		call	sub_322
		pop	di
		pop	si
		retn
start		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

__checknull	proc near
		retn
__checknull	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn	bp-based frame

__terminate	proc near

arg_0		= byte ptr  2

		mov	bp, sp
		mov	ah, 4Ch
		mov	al, [bp+arg_0]
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
__terminate	endp			; AL = exit code


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

sub_25F		proc near
		mov	dx, offset buf	; "Divide error\r\n"
		push	dx		; buf
		call	___ErrorMessage
		pop	dx
		mov	ax, 3
		push	ax		; status
		call	__exit
sub_25F		endp


; =============== S U B	R O U T	I N E =======================================


sub_26E		proc near
		push	ds
		mov	ax, 3500h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_15CA, bx
		mov	word ptr dword_15CA+2, es
		mov	ax, 3504h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_15CE, bx
		mov	word ptr dword_15CE+2, es
		mov	ax, 3505h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_15D2, bx
		mov	word ptr dword_15D2+2, es
		mov	ax, 3506h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_15D6, bx
		mov	word ptr dword_15D6+2, es
		mov	ax, 2500h
		mov	dx, cs
		mov	ds, dx
		mov	dx, offset sub_25F
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		retn
sub_26E		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

__restorezero	proc near
		push	ds
		mov	ax, 2500h
		lds	dx, dword_15CA
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		push	ds
		mov	ax, 2504h
		lds	dx, dword_15CE
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		push	ds
		mov	ax, 2505h
		lds	dx, dword_15D2
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		push	ds
		mov	ax, 2506h
		lds	dx, dword_15D6
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		retn
__restorezero	endp


; =============== S U B	R O U T	I N E =======================================


sub_2DE		proc near
		mov	ax, 100h
		mov	dx, di
		mov	bx, si

loc_2E5:
		cmp	bx, di
		jz	short loc_302
		cmp	byte ptr es:[bx], 0FFh
		jz	short loc_2FD
		mov	cl, es:[bx+1]
		xor	ch, ch
		cmp	cx, ax
		jnb	short loc_2FD
		mov	ax, cx
		mov	dx, bx

loc_2FD:
		add	bx, 6
		jmp	short loc_2E5
; ---------------------------------------------------------------------------

loc_302:
		cmp	dx, di
		jz	short locret_321
		mov	bx, dx
		cmp	byte ptr es:[bx], 0
		mov	byte ptr es:[bx], 0FFh
		push	es
		jz	short loc_31A
		call	dword ptr es:[bx+2]
		pop	es
		jmp	short sub_2DE
; ---------------------------------------------------------------------------

loc_31A:
		call	word ptr es:[bx+2]
		pop	es
		jmp	short sub_2DE
; ---------------------------------------------------------------------------

locret_321:
		retn
sub_2DE		endp


; =============== S U B	R O U T	I N E =======================================


sub_322		proc near
		mov	ah, 0
		mov	dx, di
		mov	bx, si

loc_328:
		cmp	bx, di
		jz	short loc_343
		cmp	byte ptr es:[bx], 0FFh
		jz	short loc_33E
		cmp	es:[bx+1], ah
		jb	short loc_33E
		mov	ah, es:[bx+1]
		mov	dx, bx

loc_33E:
		add	bx, 6
		jmp	short loc_328
; ---------------------------------------------------------------------------

loc_343:
		cmp	dx, di
		jz	short locret_362
		mov	bx, dx
		cmp	byte ptr es:[bx], 0
		mov	byte ptr es:[bx], 0FFh
		push	es
		jz	short loc_35B
		call	dword ptr es:[bx+2]
		pop	es
		jmp	short sub_322
; ---------------------------------------------------------------------------

loc_35B:
		call	word ptr es:[bx+2]
		pop	es
		jmp	short sub_322
; ---------------------------------------------------------------------------

locret_362:
		retn
sub_322		endp

; ---------------------------------------------------------------------------
DGROUP@		dw 0
__MMODEL	db 2 dup(0)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_367		proc near

var_10		= byte ptr -10h
var_F		= byte ptr -0Fh
var_E		= byte ptr -0Eh
var_D		= byte ptr -0Dh
var_C		= byte ptr -0Ch
var_B		= byte ptr -0Bh
var_7		= byte ptr -7
var_6		= byte ptr -6
arg_0		= byte ptr  4

		enter	10h, 0
		push	si
		mov	si, offset aMiko_cfg ; "miko.cfg"
		lea	ax, [bp+var_6]
		push	ss
		push	ax
		push	ds
		push	offset unk_15FF
		mov	cx, 6
		call	N_SCOPY@
		push	si
		call	sub_70C
		or	ax, ax
		jnz	short loc_396

loc_386:
		push	si
		call	sub_7E8
		push	ss
		lea	ax, [bp+var_6]
		push	ax
		push	6
		call	sub_742
		jmp	short loc_3DC
; ---------------------------------------------------------------------------

loc_396:
		push	ss
		lea	ax, [bp+var_10]
		push	ax
		push	0Ah
		call	sub_5DE
		call	sub_6FE
		mov	al, [bp+var_10]
		cbw
		push	ax
		mov	al, [bp+var_F]
		cbw
		pop	dx
		add	dx, ax
		mov	al, [bp+var_E]
		cbw
		add	dx, ax
		mov	al, [bp+var_D]
		cbw
		add	dx, ax
		mov	al, [bp+var_C]
		cbw
		add	dx, ax
		mov	al, [bp+var_B]
		cbw
		add	dx, ax
		mov	al, [bp+var_7]
		cbw
		cmp	dx, ax
		jnz	short loc_386
		push	si
		call	sub_866
		push	0
		push	6
		push	0
		call	sub_824

loc_3DC:
		push	ss
		lea	ax, [bp+arg_0]
		push	ax
		push	2
		call	sub_742
		push	ds
		push	offset byte_15FE
		push	1
		call	sub_742
		push	ss
		lea	ax, [bp+var_7]
		push	ax
		push	1
		call	sub_742
		call	sub_6FE
		pop	si
		leave
		retn
sub_367		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
_main		proc near

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= word ptr -4
var_2		= word ptr -2
_argc		= word ptr  4
_argv		= word ptr  6
_envp		= word ptr  8

		enter	0Ch, 0
		push	si
		push	di
		mov	si, [bp+_argv]
		mov	[bp+var_2], offset aHumaconfig ; "HUMAConfig"
		push	[bp+var_2]
		push	0Ah
		push	10h
		call	sub_520
		mov	di, ax
		push	offset aUmx	; "\n\n東方幻想郷用　 常駐プログラム　RES_HU"...
		call	sub_8DC
		call	sub_4FC
		cmp	[bp+_argc], 2
		jnz	short loc_485
		mov	bx, [si+2]
		cmp	byte ptr [bx], '-'
		jz	short loc_435
		cmp	byte ptr [bx], '/'
		jnz	short loc_45A

loc_435:
		mov	bx, [si+2]
		cmp	byte ptr [bx+1], 'R'
		jz	short loc_444
		cmp	byte ptr [bx+1], 'r'
		jnz	short loc_45A

loc_444:
		or	di, di
		jnz	short loc_44D
		push	offset aVavVBavVVvvVV ;	"わたし、まだいませんよぉ\n\n"
		jmp	short loc_4A4
; ---------------------------------------------------------------------------

loc_44D:
		push	di
		call	sub_8B6
		push	offset aVVcvVcbavVIqvj ; "さよなら、また会えたらいいな\n\n"
		call	sub_8DC
		jmp	loc_4F5
; ---------------------------------------------------------------------------

loc_45A:
		mov	bx, [si+2]
		cmp	byte ptr [bx], '-'
		jz	short loc_467
		cmp	byte ptr [bx], '/'
		jnz	short loc_47D

loc_467:
		mov	bx, [si+2]
		cmp	byte ptr [bx+1], 'D'
		jz	short loc_476
		cmp	byte ptr [bx+1], 'd'
		jnz	short loc_47D

loc_476:
		mov	byte_15FE, 1
		jmp	short loc_485
; ---------------------------------------------------------------------------

loc_47D:
		push	offset aVV	; "そんなオプション付けられても、困るんで・...
		call	sub_8DC
		jmp	short loc_4A7
; ---------------------------------------------------------------------------

loc_485:
		or	di, di
		jz	short loc_491
		push	offset aVavVBavVVVvvVV ; "わたし、すでにいますよぉ\n\n"
		call	sub_8DC
		jmp	short loc_4A7
; ---------------------------------------------------------------------------

loc_491:
		push	[bp+var_2]
		push	0Ah
		push	10h
		call	sub_568
		mov	di, ax
		or	di, di
		jnz	short loc_4AC
		push	offset aNVVVV	; "作れません、わたしの居場所がないの！\n\n"

loc_4A4:
		call	sub_8DC

loc_4A7:
		mov	ax, 1
		jmp	short loc_4F7
; ---------------------------------------------------------------------------

loc_4AC:
		mov	word ptr [bp+var_8+2], di
		mov	word ptr [bp+var_8], 0
		push	offset aVVVVBavcvivVnv ; "それでは、よろしくお願いします\n\n"
		call	sub_8DC
		mov	[bp+var_4], 0Bh
		jmp	short loc_4CE
; ---------------------------------------------------------------------------

loc_4C1:
		les	bx, [bp+var_8]
		add	bx, [bp+var_4]
		mov	byte ptr es:[bx], 0
		inc	[bp+var_4]

loc_4CE:
		cmp	[bp+var_4], 100h
		jl	short loc_4C1
		push	di
		call	sub_367
		pop	cx
		mov	dx, word ptr [bp+var_8+2]
		mov	ax, word ptr [bp+var_8]
		mov	word ptr [bp+var_C+2], dx
		mov	word ptr [bp+var_C], ax
		cmp	byte_15FE, 0
		jz	short loc_4F5
		les	bx, [bp+var_C]
		mov	byte ptr es:[bx+1Ah], 1

loc_4F5:
		xor	ax, ax

loc_4F7:
		pop	di
		pop	si
		leave
		retn
_main		endp

; ---------------------------------------------------------------------------
		db 0

; =============== S U B	R O U T	I N E =======================================


sub_4FC		proc near
		mov	al, 80h
		pushf
		cli
		out	7Ch, al
		popf
		xor	ax, ax
		mov	dx, 7Eh
		out	dx, al
		out	dx, al
		out	dx, al
		out	dx, al
		mov	bx, di
		xor	di, di
		mov	cx, word_1792
		mov	es, word_1790
		assume es:nothing
		rep stosw
		mov	di, bx
		out	7Ch, al
		retn
sub_4FC		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_520		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ah, 52h
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		cld
		mov	bx, es:[bx-2]

loc_52E:
		mov	es, bx
		assume es:nothing
		inc	bx
		mov	ax, es:1
		or	ax, ax
		jz	short loc_54F
		mov	ax, es:3
		cmp	ax, [bp+arg_0]
		jnz	short loc_54F
		mov	cx, [bp+arg_2]
		mov	si, [bp+arg_4]
		mov	di, 10h
		repe cmpsb
		jz	short loc_560

loc_54F:
		mov	ax, es:3
		add	bx, ax
		mov	al, es:0
		cmp	al, 4Dh
		jz	short loc_52E
		mov	bx, 0

loc_560:
		mov	ax, bx
		pop	di
		pop	si
		pop	bp
		retn	6
sub_520		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_568		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+arg_4]
		push	[bp+arg_2]
		push	[bp+arg_0]
		call	sub_520
		or	ax, ax
		jnz	short loc_5D7
		mov	ax, 5800h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: get allocation strategy
		mov	dx, ax
		mov	ax, 5801h
		mov	bx, 1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	ah, 48h
		mov	bx, [bp+arg_0]
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	cx, 0
		jb	short loc_5CE
		mov	bx, cs
		cmp	bx, ax
		jnb	short loc_5B3
		mov	es, ax
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	ax, 5801h
		mov	bx, 2
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	ah, 48h
		mov	bx, [bp+arg_0]
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired

loc_5B3:
		mov	cx, ax
		push	ax
		dec	cx
		mov	es, cx
		assume es:nothing
		mov	ax, 0FFFFh
		mov	es:1, ax
		inc	cx
		mov	es, cx
		assume es:nothing
		xor	di, di
		mov	cx, [bp+arg_2]
		mov	si, [bp+arg_4]
		rep movsb
		pop	cx

loc_5CE:
		mov	ax, 5801h
		mov	bx, dx
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	ax, cx

loc_5D7:
		pop	di
		pop	si
		pop	bp
		retn	6
sub_568		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_5DE		proc near

arg_0		= word ptr  4
arg_2		= dword	ptr  6

		push	bp
		mov	bp, sp
		push	si
		push	di
		cmp	word_17A6, 0
		jz	short loc_662
		mov	bx, [bp+arg_0]
		les	di, [bp+arg_2]
		assume es:nothing

loc_5F0:
		mov	ax, word ptr unk_19E8
		cmp	word_19E6, ax
		jb	short loc_626
		add	word_19E2, ax
		adc	word_19E4, 0
		push	bx
		push	ds
		mov	cx, word_17A6
		mov	bx, word_17A8
		lds	dx, dword ptr unk_19DE
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds
		pop	bx
		cmc
		sbb	dx, dx
		and	ax, dx
		mov	word ptr unk_19E8, ax
		jz	short loc_681
		mov	word_19E6, 0

loc_626:
		mov	si, word ptr unk_19E8
		sub	si, word_19E6
		sub	si, bx
		sbb	ax, ax
		and	si, ax
		add	si, bx
		mov	ax, es
		or	ax, di
		jz	short loc_657
		or	si, si
		jz	short loc_657
		push	si
		push	ds
		mov	cx, si
		mov	ax, word_19E6
		lds	si, dword ptr unk_19DE
		add	si, ax
		shr	cx, 1
		rep movsw
		adc	cx, cx
		rep movsb
		pop	ds
		pop	si

loc_657:
		add	word_19E6, si
		sub	bx, si
		jnz	short loc_5F0
		jmp	short loc_687
; ---------------------------------------------------------------------------
		nop

loc_662:
		push	ds
		mov	cx, [bp+arg_0]
		mov	bx, word_17A8
		lds	dx, [bp+arg_2]
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds
		add	word_19E2, ax
		adc	word_19E4, 0
		mov	bx, cx
		sub	bx, ax
		jz	short loc_687

loc_681:
		mov	word ptr unk_19EA, 1

loc_687:
		mov	ax, [bp+arg_0]
		sub	ax, bx
		pop	di
		pop	si
		pop	bp
		retn	6
sub_5DE		endp


; =============== S U B	R O U T	I N E =======================================


sub_692		proc near
		mov	bx, word_17A8
		cmp	bx, 0FFFFh
		jz	short locret_6FC
		mov	ax, word_19E6
		cmp	word ptr unk_19E8, ax
		jnb	short loc_6D0
		push	ds
		mov	cx, word_19E6
		lds	dx, dword ptr unk_19DE
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	ds
		jb	short loc_6C3
		add	word_19E2, ax
		adc	word_19E4, 0
		cmp	word_19E6, ax
		jz	short loc_6C9

loc_6C3:
		mov	word ptr unk_19EC, 1

loc_6C9:
		mov	word_19E6, 0
		retn
; ---------------------------------------------------------------------------

loc_6D0:
		cmp	word ptr unk_19E8, 0
		jz	short locret_6FC
		mov	dx, ax
		mov	cx, 0
		add	dx, word_19E2
		mov	word ptr unk_19E8, cx
		mov	word_19E6, cx
		adc	cx, word_19E4
		mov	ax, 4200h
		mov	bx, word_17A8
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		mov	word_19E2, ax
		mov	word_19E4, dx

locret_6FC:
		retn
sub_692		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_6FE		proc near
		call	sub_692
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	word_17A8, 0FFFFh
		retn
sub_6FE		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_70C		proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		xor	ax, ax
		mov	bx, word_17A8
		cmp	bx, 0FFFFh
		jnz	short loc_73E
		push	[bp+arg_0]
		call	sub_904
		sbb	bx, bx
		or	ax, bx
		mov	word_17A8, ax
		xor	ax, ax
		mov	word ptr unk_19E8, ax
		mov	word_19E2, ax
		mov	word_19E4, ax
		mov	word_19E6, ax
		mov	word ptr unk_19EA, ax
		mov	word ptr unk_19EC, ax
		lea	ax, [bx+1]

loc_73E:
		pop	bp
		retn	2
sub_70C		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_742		proc near

arg_0		= word ptr  4
arg_2		= dword	ptr  6

		push	bp
		mov	bp, sp
		push	si
		push	di
		cmp	word_17A6, 0
		jz	short loc_7B8
		mov	bx, [bp+arg_0]
		mov	si, word ptr [bp+arg_2]

loc_754:
		mov	cx, word_17A6
		sub	cx, word_19E6
		sub	cx, bx
		sbb	ax, ax
		and	cx, ax
		add	cx, bx
		les	di, dword ptr unk_19DE
		add	di, word_19E6
		sub	bx, cx
		add	word_19E6, cx
		push	ds
		mov	ds, word ptr [bp+arg_2+2]
		shr	cx, 1
		rep movsw
		adc	cx, cx
		rep movsb
		pop	ds
		or	ax, ax
		jns	short loc_7AE
		push	ds
		push	bx
		mov	cx, word_17A6
		mov	bx, word_17A8
		lds	dx, dword ptr unk_19DE
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	bx
		pop	ds
		jb	short loc_7CA
		cmp	word_17A6, ax
		jnz	short loc_7CA
		mov	word_19E6, 0
		add	word_19E2, ax
		adc	word_19E4, 0

loc_7AE:
		or	bx, bx
		jnz	short loc_754
		mov	ax, 1
		jmp	short loc_7E0
; ---------------------------------------------------------------------------
		nop

loc_7B8:
		push	ds
		mov	cx, [bp+arg_0]
		mov	bx, word_17A8
		lds	dx, [bp+arg_2]
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	ds
		jnb	short loc_7D2

loc_7CA:
		mov	word ptr unk_19EC, 1
		xor	ax, ax

loc_7D2:
		add	word_19E2, ax
		adc	word_19E4, 0
		add	ax, 0FFFFh
		sbb	ax, ax

loc_7E0:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn	6
sub_742		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_7E8		proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		mov	ax, 0
		mov	bx, word_17A8
		cmp	bx, 0FFFFh
		jnz	short loc_81F
		mov	cx, 20h
		mov	ah, 3Ch
		push	ax
		push	[bp+arg_0]
		call	sub_8C6
		or	ax, dx
		mov	word_17A8, ax
		xor	ax, ax
		mov	word ptr unk_19E8, ax
		mov	word_19E6, ax
		mov	word ptr unk_19EA, ax
		mov	word ptr unk_19EC, ax
		mov	word_19E2, ax
		mov	word_19E4, ax
		mov	ax, dx
		inc	ax

loc_81F:
		pop	bp
		retn	2
sub_7E8		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_824		proc near
		call	sub_692
		cmp	bx, 0FFFFh
		jz	short locret_854
		push	bp
		mov	bp, sp
		mov	al, [bp+4]
		mov	ah, 42h
		mov	dx, [bp+6]
		mov	cx, [bp+8]
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method:
					; 0-from beginnig,1-from current,2-from	end
		pop	bp
		mov	ax, 4201h
		mov	dx, 0
		mov	cx, dx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from present location
		mov	word ptr unk_19EA, 0
		mov	word_19E2, ax
		mov	word_19E4, dx

locret_854:
		retn	6
sub_824		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_858		proc near
		mov	ax, word_19E6
		xor	dx, dx
		add	ax, word_19E2
		adc	dx, word_19E4
		retn
sub_858		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_866		proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		mov	ax, 0
		mov	bx, word_17A8
		cmp	bx, 0FFFFh
		jnz	short loc_8B2
		mov	ax, 3D02h
		push	ax
		push	[bp+arg_0]
		call	sub_8C6
		or	ax, dx
		mov	word_17A8, ax
		mov	cx, ax
		xor	ax, ax
		mov	word ptr unk_19E8, ax
		mov	word_19E6, ax
		mov	word ptr unk_19EA, ax
		mov	word ptr unk_19EC, ax
		mov	word_19E2, ax
		mov	word_19E4, ax
		inc	dx
		jz	short loc_8B2
		mov	bx, cx
		xor	cx, cx
		mov	dx, cx
		mov	ax, 4202h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		mov	word_19E2, ax
		mov	word_19E4, dx
		mov	ax, 1

loc_8B2:
		pop	bp
		retn	2
sub_866		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_8B6		proc near

arg_0		= word ptr  6

		push	bp
		push	es
		mov	bp, sp
		mov	es, [bp+arg_0]
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es
		pop	bp
		retn	2
sub_8B6		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_8C6		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6

		push	bp
		mov	bp, sp
		mov	dx, [bp+arg_0]
		mov	ax, [bp+arg_2]
		int	21h		; DOS -
		sbb	dx, dx
		xor	ax, dx
		sub	ax, dx
		pop	bp
		retn	4
sub_8C6		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_8DC		proc near
		mov	bx, sp
		mov	cx, si
		mov	si, ss:[bx+2]
		lodsb
		or	al, al
		jz	short loc_8FE
		mov	ah, 2

loc_8EB:
		cmp	al, 0Ah
		jnz	short loc_8F5
		mov	dl, 0Dh
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		mov	al, 0Ah

loc_8F5:
		mov	dl, al
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		lodsb
		or	al, al
		jnz	short loc_8EB

loc_8FE:
		mov	si, cx
		retn	2
sub_8DC		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_904		proc near
		mov	bx, sp
		mov	ah, 3Dh
		mov	al, byte_17AA
		mov	dx, ss:[bx+2]
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short loc_916
		retn	2
; ---------------------------------------------------------------------------

loc_916:
		mov	ax, 0FFFEh
		retn	2
sub_904		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

sub_91C		proc near
		push	si
		push	di
		mov	ax, offset aAbnormalProgra ; "Abnormal program termination\r\n"
		push	ax		; buf
		call	___ErrorMessage
		mov	ax, 3
		push	ax		; status
		call	__exit
; ---------------------------------------------------------------------------
		pop	cx
		pop	cx
		pop	di
		pop	si
		retn
sub_91C		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl atexit(void (*func)(void))
_atexit		proc near

func		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		cmp	word_17CC, 20h
		jnz	short loc_942
		mov	ax, 1
		jmp	short loc_955
; ---------------------------------------------------------------------------

loc_942:
		mov	bx, word_17CC
		add	bx, bx
		mov	ax, [bp+func]
		mov	word_19EE[bx], ax
		inc	word_17CC
		xor	ax, ax

loc_955:
		pop	di
		pop	si
		pop	bp
		retn
_atexit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl __ErrorMessage(char *buf)
___ErrorMessage	proc near

_buf		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+_buf]	; s
		call	_strlen
		pop	cx
		push	ax		; len
		push	[bp+_buf]	; buf
		mov	al, stru_17F4.fd
		cbw
		push	ax		; handle
		call	__rtl_write
		add	sp, 6
		pop	di
		pop	si
		pop	bp
		retn
___ErrorMessage	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_978		proc near
		push	si
		push	di
		pop	di
		pop	si
		retn
sub_978		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

sub_97D		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		cmp	[bp+arg_4], 0
		jnz	short loc_9A6
		jmp	short loc_998
; ---------------------------------------------------------------------------

loc_98A:
		dec	word_17CC
		mov	bx, word_17CC
		add	bx, bx
		call	word_19EE[bx]

loc_998:
		cmp	word_17CC, 0
		jnz	short loc_98A
		call	__cleanup
		call	off_17CE

loc_9A6:
		call	__restorezero
		call	__checknull
		cmp	[bp+arg_2], 0
		jnz	short loc_9C7
		cmp	[bp+arg_4], 0
		jnz	short loc_9C0
		call	off_17D0
		call	off_17D2

loc_9C0:
		push	[bp+arg_0]
		call	__terminate
; ---------------------------------------------------------------------------
		pop	cx

loc_9C7:
		pop	di
		pop	si
		pop	bp
		retn	6
sub_97D		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn	bp-based frame

; void __cdecl exit(int	status)
_exit		proc near

status		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		xor	ax, ax
		push	ax
		push	ax
		push	[bp+status]
		call	sub_97D
		pop	di
		pop	si
		pop	bp
		retn
_exit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn	bp-based frame

; void __cdecl _exit(int status)
__exit		proc near

status		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, 1
		push	ax
		xor	ax, ax
		push	ax
		push	[bp+status]
		call	sub_97D
		pop	di
		pop	si
		pop	bp
		retn
__exit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void _cexit(void)
__cexit		proc near
		push	si
		push	di
		xor	ax, ax
		push	ax
		mov	ax, 1
		push	ax
		xor	ax, ax
		push	ax
		call	sub_97D
		pop	di
		pop	si
		retn
__cexit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void _c_exit(void)
__c_exit	proc near
		push	si
		push	di
		mov	ax, 1
		push	ax
		push	ax
		xor	ax, ax
		push	ax
		call	sub_97D
		pop	di
		pop	si
		retn
__c_exit	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

__IOERROR	proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	dx, [bp+arg_0]
		or	dx, dx
		jl	short loc_A3B
		cmp	dx, 58h
		jle	short loc_A2C

loc_A29:
		mov	dx, 57h

loc_A2C:
		mov	word_1940, dx
		mov	bx, dx
		mov	al, byte_1942[bx]
		cbw
		mov	dx, ax
		jmp	short loc_A49
; ---------------------------------------------------------------------------

loc_A3B:
		neg	dx
		cmp	dx, word_19B8
		jg	short loc_A29
		mov	word_1940, 0FFFFh

loc_A49:
		mov	word_15EA, dx
		mov	ax, 0FFFFh
		pop	di
		pop	si
		pop	bp
		retn	2
__IOERROR	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

__DOSERROR	proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+arg_0]
		call	__IOERROR
		mov	ax, [bp+arg_0]
		pop	di
		pop	si
		pop	bp
		retn	2
__DOSERROR	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl isatty(int handle)
_isatty		proc near

handle		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, 4400h
		mov	bx, [bp+handle]
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		xchg	ax, dx
		and	ax, 80h
		pop	di
		pop	si
		pop	bp
		retn
_isatty		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; __int32 __cdecl lseek(int handle, __int32 offset, int	fromwhere)
_lseek		proc near

handle		= word ptr  4
_offset		= word ptr  6
arg_4		= word ptr  8
fromwhere	= byte ptr  0Ah

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	bx, [bp+handle]
		add	bx, bx
		and	word_1916[bx], 0FDFFh
		mov	ah, 42h
		mov	al, [bp+fromwhere]
		mov	bx, [bp+handle]
		mov	cx, [bp+arg_4]
		mov	dx, [bp+_offset]
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method:
					; 0-from beginnig,1-from current,2-from	end
		jb	short loc_AA3
		jmp	short loc_AA8
; ---------------------------------------------------------------------------

loc_AA3:
		push	ax
		call	__IOERROR
		cwd

loc_AA8:
		pop	di
		pop	si
		pop	bp
		retn
_lseek		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

N_SCOPY@	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	ds
		lds	si, [bp+arg_0]
		les	di, [bp+arg_4]
		cld
		shr	cx, 1
		rep movsw
		adc	cx, cx
		rep movsb
		pop	ds
		pop	di
		pop	si
		pop	bp
		retn	8
N_SCOPY@	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

__setupio	proc near
		push	si
		push	di
		mov	dx, 5
		jmp	short loc_AF4
; ---------------------------------------------------------------------------

loc_ACF:
		mov	bx, dx
		add	bx, bx
		mov	word_1916[bx], 0
		mov	bx, dx
		mov	cl, 4
		shl	bx, cl
		mov	stream.fd[bx], 0FFh
		mov	ax, dx
		shl	ax, cl
		add	ax, offset stream
		mov	bx, dx
		shl	bx, cl
		mov	stream.token[bx], ax
		inc	dx

loc_AF4:
		cmp	dx, word_1914
		jb	short loc_ACF
		mov	al, stream.fd
		cbw
		push	ax		; handle
		call	_isatty
		pop	cx
		or	ax, ax
		jnz	short loc_B0D
		and	stream.flags, 0FDFFh

loc_B0D:
		mov	ax, 200h
		push	ax		; size
		test	byte ptr stream.flags+1, 2
		jz	short loc_B1D
		mov	ax, 1
		jmp	short loc_B1F
; ---------------------------------------------------------------------------

loc_B1D:
		xor	ax, ax

loc_B1F:
		push	ax		; type
		xor	ax, ax
		push	ax		; buf
		mov	ax, offset stream
		push	ax		; stream
		call	_setvbuf
		add	sp, 8
		mov	al, stru_17E4.fd
		cbw
		push	ax		; handle
		call	_isatty
		pop	cx
		or	ax, ax
		jnz	short loc_B40
		and	stru_17E4.flags, 0FDFFh

loc_B40:
		mov	ax, 200h
		push	ax		; size
		test	byte ptr stru_17E4.flags+1, 2
		jz	short loc_B50
		mov	ax, 2
		jmp	short loc_B52
; ---------------------------------------------------------------------------

loc_B50:
		xor	ax, ax

loc_B52:
		push	ax		; type
		xor	ax, ax
		push	ax		; buf
		mov	ax, offset stru_17E4
		push	ax		; stream
		call	_setvbuf
		add	sp, 8
		pop	di
		pop	si
		retn
__setupio	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

___brk		proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, [bp+arg_0]
		mov	dx, sp
		sub	dx, 200h
		cmp	ax, dx
		jnb	short loc_B7C
		mov	off_15F0, ax
		xor	ax, ax
		jmp	short loc_B85
; ---------------------------------------------------------------------------

loc_B7C:
		mov	word_15EA, 8
		mov	ax, 0FFFFh

loc_B85:
		pop	di
		pop	si
		pop	bp
		retn
___brk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

___sbrk		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, [bp+arg_0]
		mov	dx, [bp+arg_2]
		add	ax, off_15F0
		adc	dx, 0
		mov	cx, ax
		or	dx, dx
		jnz	short loc_BB1
		add	cx, 200h
		jb	short loc_BB1
		cmp	cx, sp
		jnb	short loc_BB1
		xchg	ax, off_15F0
		jmp	short loc_BBA
; ---------------------------------------------------------------------------

loc_BB1:
		mov	word_15EA, 8
		mov	ax, 0FFFFh

loc_BBA:
		pop	di
		pop	si
		pop	bp
		retn
___sbrk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl brk(void *addr)
_brk		proc near

addr		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+addr]
		call	___brk
		pop	cx
		pop	di
		pop	si
		pop	bp
		retn
_brk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; void *__cdecl	sbrk(int incr)
_sbrk		proc near

incr		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, [bp+incr]
		cwd
		push	dx
		push	ax
		call	___sbrk
		pop	cx
		pop	cx
		pop	di
		pop	si
		pop	bp
		retn
_sbrk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void __cdecl free(void *block)
_free		proc near

block		= word ptr  2

		push	si
		push	di
		mov	si, sp
		mov	bx, [si+6]
		sub	bx, 4
		jb	short loc_BFC
		cmp	bx, word_19A0
		jz	short loc_BF9
		call	sub_C39
		jmp	short loc_BFC
; ---------------------------------------------------------------------------

loc_BF9:
		call	sub_BFF

loc_BFC:
		pop	di
		pop	si
		retn
_free		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_BFF		proc near
		cmp	word_199E, bx
		jz	short loc_C28
		mov	si, [bx+2]
		test	byte ptr [si], 1
		jz	short loc_C13
		mov	word_19A0, si
		jmp	short loc_C33
; ---------------------------------------------------------------------------

loc_C13:
		cmp	si, word_199E
		jz	short loc_C26
		mov	bx, si
		call	sub_C72
		mov	ax, [bx+2]
		mov	word_19A0, ax
		jmp	short loc_C33
; ---------------------------------------------------------------------------

loc_C26:
		mov	bx, si

loc_C28:
		xor	ax, ax
		mov	word_199E, ax
		mov	word_19A0, ax
		mov	word_19A2, ax

loc_C33:
		push	bx
		call	___brk
		pop	bx
		retn
sub_BFF		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_C39		proc near
		dec	word ptr [bx]
		cmp	bx, word_199E
		jz	short loc_C59
		mov	si, [bx+2]
		mov	ax, [si]
		test	al, 1
		jnz	short loc_C59
		add	ax, [bx]
		mov	[si], ax
		mov	di, [bx]
		add	di, bx
		mov	[di+2],	si
		mov	bx, si
		jmp	short loc_C5C
; ---------------------------------------------------------------------------

loc_C59:
		call	sub_C8E

loc_C5C:
		mov	di, [bx]
		add	di, bx
		mov	ax, [di]
		test	al, 1
		jz	short loc_C67
		retn
; ---------------------------------------------------------------------------

loc_C67:
		add	[bx], ax
		mov	si, di
		add	si, ax
		mov	[si+2],	bx
		mov	bx, di
sub_C39		endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_C72		proc near
		mov	di, [bx+6]
		cmp	bx, di
		jz	short loc_C87
		mov	word_19A2, di
		mov	si, [bx+4]
		mov	[di+4],	si
		mov	[si+6],	di
		retn
; ---------------------------------------------------------------------------

loc_C87:
		mov	word_19A2, 0
		retn
sub_C72		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_C8E		proc near
		mov	si, word_19A2
		or	si, si
		jz	short loc_CA6
		mov	di, [si+6]
		mov	[si+6],	bx
		mov	[di+4],	bx
		mov	[bx+6],	di
		mov	[bx+4],	si
		retn
; ---------------------------------------------------------------------------

loc_CA6:
		mov	word_19A2, bx
		mov	[bx+4],	bx
		mov	[bx+6],	bx
		retn
sub_C8E		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void *__cdecl	malloc(size_t size)
_malloc		proc near

_size		= word ptr  2

		push	si
		push	di
		mov	si, sp
		mov	ax, [si+6]
		or	ax, ax
		jz	short loc_D0E
		add	ax, 5
		jb	short loc_CF7
		and	ax, 0FFFEh
		cmp	ax, 8
		jnb	short loc_CCC
		mov	ax, 8

loc_CCC:
		cmp	word_199E, 0
		jz	short loc_CF2
		mov	bx, word_19A2
		or	bx, bx
		jz	short loc_CE8
		mov	dx, bx

loc_CDD:
		cmp	[bx], ax
		jnb	short loc_CFB
		mov	bx, [bx+6]
		cmp	bx, dx
		jnz	short loc_CDD

loc_CE8:
		call	sub_D51
		jmp	short loc_D0E
; ---------------------------------------------------------------------------

loc_CED:
		call	sub_D7A
		jmp	short loc_D0E
; ---------------------------------------------------------------------------

loc_CF2:
		call	sub_D11
		jmp	short loc_D0E
; ---------------------------------------------------------------------------

loc_CF7:
		xor	ax, ax
		jmp	short loc_D0E
; ---------------------------------------------------------------------------

loc_CFB:
		mov	si, ax
		add	si, 8
		cmp	[bx], si
		jnb	short loc_CED
		call	sub_C72
		inc	word ptr [bx]
		mov	ax, bx
		add	ax, 4

loc_D0E:
		pop	di
		pop	si
		retn
_malloc		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_D11		proc near
		push	ax
		xor	ax, ax
		push	ax
		push	ax
		call	___sbrk
		pop	bx
		pop	bx
		and	ax, 1
		jz	short loc_D29
		xor	dx, dx
		push	dx
		push	ax
		call	___sbrk
		pop	bx
		pop	bx

loc_D29:
		pop	ax
		push	ax
		xor	bx, bx
		push	bx
		push	ax
		call	___sbrk
		pop	bx
		pop	bx
		cmp	ax, 0FFFFh
		jz	short loc_D4D
		mov	bx, ax
		mov	word_199E, bx
		mov	word_19A0, bx
		pop	ax
		inc	ax
		mov	[bx], ax
		add	bx, 4
		mov	ax, bx
		retn
; ---------------------------------------------------------------------------

loc_D4D:
		pop	bx
		xor	ax, ax
		retn
sub_D11		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_D51		proc near
		push	ax
		xor	bx, bx
		push	bx
		push	ax
		call	___sbrk
		pop	bx
		pop	bx
		cmp	ax, 0FFFFh
		jz	short loc_D76
		mov	bx, ax
		mov	ax, word_19A0
		mov	[bx+2],	ax
		mov	word_19A0, bx
		pop	ax
		inc	ax
		mov	[bx], ax
		add	bx, 4
		mov	ax, bx
		retn
; ---------------------------------------------------------------------------

loc_D76:
		pop	ax
		xor	ax, ax
		retn
sub_D51		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_D7A		proc near
		sub	[bx], ax
		mov	si, bx
		add	si, [bx]
		mov	di, si
		add	di, ax
		inc	ax
		mov	[si], ax
		mov	[si+2],	bx
		mov	[di+2],	si
		add	si, 4
		mov	ax, si
		retn
sub_D7A		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __fastcall sub_D93(size_t	size)
sub_D93		proc near

var_2		= word ptr -2

		mov	bp, sp
		push	bx
		push	ax
		push	cx
		push	ax		; size
		call	_malloc
		pop	bx
		mov	bx, ax
		or	ax, ax
		jz	short loc_DC2
		push	ds
		pop	es
		assume es:seg000
		cld
		mov	di, ax
		mov	si, [bp+var_2]
		mov	cx, [si]
		add	si, 4
		push	si		; block
		sub	cx, 5
		shr	cx, 1
		rep movsw
		mov	[bp+var_2], ax
		call	_free
		pop	bx
		mov	bx, [bp+var_2]

loc_DC2:
		add	sp, 6
		retn
sub_D93		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_DC6		proc near
		mov	ax, dx
		add	dx, 8
		cmp	dx, cx
		ja	short loc_E04
		mov	dx, cx
		cmp	bx, word_19A0
		jnz	short loc_DE6
		mov	[bx], ax
		inc	word ptr [bx]
		add	ax, bx
		push	bx
		push	ax
		call	___brk
		pop	bx
		pop	bx
		jmp	short loc_E04
; ---------------------------------------------------------------------------

loc_DE6:
		mov	di, bx
		add	di, ax
		mov	[di+2],	bx
		sub	dx, ax
		sub	[bx], dx
		mov	si, di
		add	si, dx
		mov	[si+2],	di
		inc	dx
		mov	[di], dx
		mov	cx, bx
		mov	bx, di
		call	sub_C39
		mov	bx, cx

loc_E04:
		add	bx, 4
		retn
sub_DC6		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; void *__cdecl	realloc(void *block, size_t size)
_realloc	proc near

block		= word ptr  8
_size		= word ptr  0Ah

		push	si
		push	di
		push	bp
		mov	bp, sp
		mov	bx, [bp+block]
		mov	ax, [bp+_size]
		or	ax, ax
		jz	short loc_E4E
		or	bx, bx
		jz	short loc_E48
		sub	bx, 4
		mov	cx, [bx]
		dec	cx
		mov	dx, ax
		add	dx, 5
		and	dx, 0FFFEh
		cmp	dx, 8
		jnb	short loc_E31
		mov	dx, 8

loc_E31:
		cmp	cx, dx
		jb	short loc_E41
		ja	short loc_E3C
		add	bx, 4
		jmp	short loc_E44
; ---------------------------------------------------------------------------

loc_E3C:
		call	sub_DC6
		jmp	short loc_E44
; ---------------------------------------------------------------------------

loc_E41:
		call	sub_D93

loc_E44:
		mov	ax, bx
		jmp	short loc_E55
; ---------------------------------------------------------------------------

loc_E48:
		push	ax		; size
		call	_malloc
		jmp	short loc_E54
; ---------------------------------------------------------------------------

loc_E4E:
		push	bx		; block
		call	_free
		xor	ax, ax

loc_E54:
		pop	bx

loc_E55:
		pop	bp
		pop	di
		pop	si
		retn
_realloc	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_E59		proc near
		push	ax
		push	cx
		push	dx
		push	bx
		push	sp
		push	bp
		push	si
		push	di
		push	ds
		push	es
		mov	bp, sp
		mov	ax, word ptr dword_19A4
		or	ax, word ptr dword_19A4+2
		jnz	short loc_E94
		mov	si, 0FFFFh
		push	ds
		mov	ax, 6300h
		clc
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		mov	ax, ds
		pop	ds
		jb	short loc_E88
		mov	dx, ds
		cmp	ax, dx
		jz	short loc_E88
		cmp	si, 0FFFFh
		jnz	short loc_E8D

loc_E88:
		mov	si, offset byte_19A8
		mov	ax, ds

loc_E8D:
		mov	word ptr dword_19A4, si
		mov	word ptr dword_19A4+2, ax

loc_E94:
		mov	sp, bp
		pop	es
		assume es:nothing
		pop	ds
		pop	di
		pop	si
		pop	bp
		pop	bx
		pop	bx
		pop	dx
		pop	cx
		pop	ax
		retn
sub_E59		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_EA1		proc near

arg_0		= byte ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	al, [bp+arg_0]
		xor	cx, cx
		les	bx, dword_19A4

loc_EAF:
		mov	dx, es:[bx]
		or	dx, dx
		jz	short loc_EC1
		cmp	al, dl
		jb	short loc_EC1
		inc	bx
		inc	bx
		cmp	al, dh
		ja	short loc_EAF
		inc	cx

loc_EC1:
		xchg	ax, cx
		pop	di
		pop	si
		pop	bp
		retn
sub_EA1		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_EC6		proc near

var_2		= word ptr -2
arg_0		= word ptr  4
arg_2		= word ptr  6

		push	bp
		mov	bp, sp
		sub	sp, 2
		push	si
		push	di
		xor	dx, dx
		mov	ax, [bp+arg_0]
		mov	[bp+var_2], ax

loc_ED6:
		mov	bx, [bp+var_2]
		cmp	byte ptr [bx], 0
		jnz	short loc_EE2
		xor	dx, dx
		jmp	short loc_F0D
; ---------------------------------------------------------------------------

loc_EE2:
		cmp	dx, 1
		jnz	short loc_EEC
		mov	dx, 2
		jmp	short loc_F00
; ---------------------------------------------------------------------------

loc_EEC:
		mov	bx, [bp+var_2]
		push	word ptr [bx]
		call	sub_EA1
		pop	cx
		or	ax, ax
		jz	short loc_EFE
		mov	dx, 1
		jmp	short loc_F00
; ---------------------------------------------------------------------------

loc_EFE:
		xor	dx, dx

loc_F00:
		mov	ax, [bp+var_2]
		cmp	ax, [bp+arg_2]
		jnb	short loc_F0D
		inc	[bp+var_2]
		jmp	short loc_ED6
; ---------------------------------------------------------------------------

loc_F0D:
		or	dx, dx
		jnz	short loc_F16
		mov	ax, 1
		jmp	short loc_F18
; ---------------------------------------------------------------------------

loc_F16:
		xor	ax, ax

loc_F18:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
sub_EC6		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl fflush(FILE *stream)
_fflush		proc near

var_2		= word ptr -2
_stream		= word ptr  4

		push	bp
		mov	bp, sp
		sub	sp, 2
		push	si
		push	di
		cmp	[bp+_stream], 0
		jnz	short loc_F31
		call	_flushall
		jmp	short loc_FA7
; ---------------------------------------------------------------------------

loc_F31:
		mov	bx, [bp+_stream]
		mov	ax, [bx+0Eh]
		cmp	ax, [bp+_stream]
		jnz	short loc_FA2
		mov	bx, [bp+_stream]
		cmp	word ptr [bx], 0
		jl	short loc_F6F
		test	byte ptr [bx+2], 8
		jnz	short loc_F55
		mov	ax, [bp+_stream]
		add	ax, 5
		cmp	[bx+0Ah], ax
		jnz	short loc_FA7

loc_F55:
		mov	bx, [bp+_stream]
		mov	word ptr [bx], 0
		mov	ax, [bp+_stream]
		add	ax, 5
		cmp	[bx+0Ah], ax
		jnz	short loc_FA7
		mov	ax, [bx+8]
		mov	[bx+0Ah], ax
		jmp	short loc_FA7
; ---------------------------------------------------------------------------

loc_F6F:
		mov	bx, [bp+_stream]
		mov	ax, [bx+6]
		add	ax, [bx]
		inc	ax
		mov	[bp+var_2], ax
		sub	[bx], ax
		push	ax		; len
		mov	ax, [bx+8]
		mov	[bx+0Ah], ax
		push	ax		; buf
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	___write
		add	sp, 6
		cmp	ax, [bp+var_2]
		jz	short loc_FA7
		mov	bx, [bp+_stream]
		test	byte ptr [bx+3], 2
		jnz	short loc_FA7
		or	word ptr [bx+2], 10h

loc_FA2:
		mov	ax, 0FFFFh
		jmp	short loc_FA9
; ---------------------------------------------------------------------------

loc_FA7:
		xor	ax, ax

loc_FA9:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
_fflush		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int flushall(void)
_flushall	proc near

var_6		= word ptr -6
var_4		= word ptr -4
_stream		= word ptr -2

		push	bp
		mov	bp, sp
		sub	sp, 6
		push	si
		push	di
		mov	[bp+var_6], 0
		mov	ax, word_1914
		mov	[bp+var_4], ax
		mov	[bp+_stream], offset stream
		jmp	short loc_FDE
; ---------------------------------------------------------------------------

loc_FC9:
		mov	bx, [bp+_stream]
		test	byte ptr [bx+2], 3
		jz	short loc_FDA
		push	bx		; stream
		call	_fflush
		pop	cx
		inc	[bp+var_6]

loc_FDA:
		add	[bp+_stream], 10h

loc_FDE:
		mov	ax, [bp+var_4]
		dec	[bp+var_4]
		or	ax, ax
		jnz	short loc_FC9
		mov	ax, [bp+var_6]
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
_flushall	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

sub_FF1		proc near

var_2		= word ptr -2
arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		sub	sp, 2
		push	si
		push	di
		mov	bx, [bp+arg_0]
		cmp	word ptr [bx], 0
		jge	short loc_100B
		mov	dx, [bx+6]
		add	dx, [bx]
		inc	dx
		mov	ax, dx
		jmp	short loc_1017
; ---------------------------------------------------------------------------

loc_100B:
		mov	bx, [bp+arg_0]
		mov	ax, [bx]
		cwd
		xor	ax, dx
		sub	ax, dx
		mov	dx, ax

loc_1017:
		mov	[bp+var_2], ax
		mov	bx, [bp+arg_0]
		test	byte ptr [bx+2], 40h
		jnz	short loc_1056
		mov	bx, [bp+arg_0]
		mov	cx, [bx+0Ah]
		cmp	word ptr [bx], 0
		jge	short loc_104F
		jmp	short loc_103B
; ---------------------------------------------------------------------------

loc_1030:
		dec	cx
		mov	bx, cx
		cmp	byte ptr [bx], 0Ah
		jnz	short loc_103B
		inc	[bp+var_2]

loc_103B:
		mov	ax, dx
		dec	dx
		or	ax, ax
		jnz	short loc_1030
		jmp	short loc_1056
; ---------------------------------------------------------------------------

loc_1044:
		mov	bx, cx
		inc	cx
		cmp	byte ptr [bx], 0Ah
		jnz	short loc_104F
		inc	[bp+var_2]

loc_104F:
		mov	ax, dx
		dec	dx
		or	ax, ax
		jnz	short loc_1044

loc_1056:
		mov	ax, [bp+var_2]
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn	2
sub_FF1		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl fseek(FILE *stream, __int32 offset, int whence)
_fseek		proc near

_stream		= word ptr  4
_offset		= dword	ptr  6
whence		= word ptr  0Ah

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+_stream]	; stream
		call	_fflush
		pop	cx
		or	ax, ax
		jz	short loc_1076
		mov	ax, 0FFFFh
		jmp	short loc_10C6
; ---------------------------------------------------------------------------

loc_1076:
		cmp	[bp+whence], 1
		jnz	short loc_108F
		mov	bx, [bp+_stream]
		cmp	word ptr [bx], 0
		jle	short loc_108F
		push	bx
		call	sub_FF1
		cwd
		sub	word ptr [bp+_offset], ax
		sbb	word ptr [bp+_offset+2],	dx

loc_108F:
		mov	bx, [bp+_stream]
		and	word ptr [bx+2], 0FE5Fh
		mov	word ptr [bx], 0
		mov	ax, [bx+8]
		mov	[bx+0Ah], ax
		push	[bp+whence]	; fromwhere
		push	word ptr [bp+_offset+2]
		push	word ptr [bp+_offset] ; offset
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		cmp	dx, 0FFFFh
		jnz	short loc_10C4
		cmp	ax, 0FFFFh
		jnz	short loc_10C4
		mov	ax, 0FFFFh
		jmp	short loc_10C6
; ---------------------------------------------------------------------------

loc_10C4:
		xor	ax, ax

loc_10C6:
		pop	di
		pop	si
		pop	bp
		retn
_fseek		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; __int32 __cdecl ftell(FILE *stream)
_ftell		proc near

var_8		= word ptr -8
var_6		= word ptr -6
_offset		= dword	ptr -4
_stream		= word ptr  4

		push	bp
		mov	bp, sp
		sub	sp, 8
		push	si
		push	di
		mov	ax, 1
		push	ax		; fromwhere
		xor	ax, ax
		push	ax
		push	ax		; offset
		mov	bx, [bp+_stream]
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		mov	word ptr [bp+_offset+2],	dx
		mov	word ptr [bp+_offset], ax
		cmp	dx, 0FFFFh
		jnz	short loc_10FB
		cmp	ax, 0FFFFh
		jnz	short loc_10FB
		jmp	loc_118B
; ---------------------------------------------------------------------------

loc_10FB:
		mov	bx, [bp+_stream]
		cmp	word ptr [bx], 0
		jge	short loc_117E
		mov	al, [bx+4]
		cbw
		add	ax, ax
		mov	bx, ax
		test	byte ptr (word_1916+1)[bx], 8
		jz	short loc_116F
		mov	ax, 2
		push	ax		; fromwhere
		xor	ax, ax
		push	ax
		push	ax		; offset
		mov	bx, [bp+_stream]
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		mov	[bp+var_6], dx
		mov	[bp+var_8], ax
		cmp	dx, 0FFFFh
		jnz	short loc_113A
		cmp	ax, 0FFFFh
		jnz	short loc_113A
		jmp	short loc_1191
; ---------------------------------------------------------------------------

loc_113A:
		xor	ax, ax
		push	ax		; fromwhere
		push	word ptr [bp+_offset+2]
		push	word ptr [bp+_offset] ; offset
		mov	bx, [bp+_stream]
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		cmp	dx, 0FFFFh
		jnz	short loc_1163
		cmp	ax, 0FFFFh
		jnz	short loc_1163
		mov	dx, 0FFFFh
		mov	ax, 0FFFFh
		jmp	short loc_1191
; ---------------------------------------------------------------------------

loc_1163:
		mov	dx, [bp+var_6]
		mov	ax, [bp+var_8]
		mov	word ptr [bp+_offset+2],	dx
		mov	word ptr [bp+_offset], ax

loc_116F:
		push	[bp+_stream]
		call	sub_FF1
		cwd
		add	word ptr [bp+_offset], ax
		adc	word ptr [bp+_offset+2],	dx
		jmp	short loc_118B
; ---------------------------------------------------------------------------

loc_117E:
		push	[bp+_stream]
		call	sub_FF1
		cwd
		sub	word ptr [bp+_offset], ax
		sbb	word ptr [bp+_offset+2],	dx

loc_118B:
		mov	dx, word ptr [bp+_offset+2]
		mov	ax, word ptr [bp+_offset]

loc_1191:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
_ftell		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl setvbuf(FILE *stream, char *buf, int type, size_t	size)
_setvbuf	proc near

_stream		= word ptr  4
_buf		= word ptr  6
_type		= word ptr  8
_size		= word ptr  0Ah

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	bx, [bp+_stream]
		mov	ax, [bx+0Eh]
		cmp	ax, [bp+_stream]
		jz	short loc_11AA
		jmp	loc_1255
; ---------------------------------------------------------------------------

loc_11AA:
		cmp	[bp+_type], 2
		jle	short loc_11B3
		jmp	loc_1255
; ---------------------------------------------------------------------------

loc_11B3:
		cmp	[bp+_size], 7FFFh
		jbe	short loc_11BD
		jmp	loc_1255
; ---------------------------------------------------------------------------

loc_11BD:
		cmp	word_19B6, 0
		jnz	short loc_11D3
		cmp	[bp+_stream], offset stru_17E4
		jnz	short loc_11D3
		mov	word_19B6, 1
		jmp	short loc_11E7
; ---------------------------------------------------------------------------

loc_11D3:
		cmp	word_19B4, 0
		jnz	short loc_11E7
		cmp	[bp+_stream], offset stream
		jnz	short loc_11E7
		mov	word_19B4, 1

loc_11E7:
		mov	bx, [bp+_stream]
		cmp	word ptr [bx], 0
		jz	short loc_11FE
		mov	ax, 1
		push	ax		; whence
		xor	ax, ax
		push	ax
		push	ax		; offset
		push	bx		; stream
		call	_fseek
		add	sp, 8

loc_11FE:
		mov	bx, [bp+_stream]
		test	byte ptr [bx+2], 4
		jz	short loc_120E
		push	word ptr [bx+8]	; block
		call	_free
		pop	cx

loc_120E:
		mov	bx, [bp+_stream]
		and	word ptr [bx+2], 0FFF3h
		mov	word ptr [bx+6], 0
		mov	ax, [bp+_stream]
		add	ax, 5
		mov	[bx+8],	ax
		mov	[bx+0Ah], ax
		cmp	[bp+_type], 2
		jz	short loc_1276
		cmp	[bp+_size], 0
		jbe	short loc_1276
		mov	off_17CE, offset __xfflush
		cmp	[bp+_buf], 0
		jnz	short loc_125A
		push	[bp+_size]	; size
		call	_malloc
		pop	cx
		mov	[bp+_buf], ax
		or	ax, ax
		jz	short loc_1255
		mov	bx, [bp+_stream]
		or	word ptr [bx+2], 4
		jmp	short loc_125A
; ---------------------------------------------------------------------------

loc_1255:
		mov	ax, 0FFFFh
		jmp	short loc_1278
; ---------------------------------------------------------------------------

loc_125A:
		mov	bx, [bp+_stream]
		mov	ax, [bp+_buf]
		mov	[bx+0Ah], ax
		mov	[bx+8],	ax
		mov	ax, [bp+_size]
		mov	[bx+6],	ax
		cmp	[bp+_type], 1
		jnz	short loc_1276
		or	word ptr [bx+2], 8

loc_1276:
		xor	ax, ax

loc_1278:
		pop	di
		pop	si
		pop	bp
		retn
_setvbuf	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; size_t __cdecl strlen(const char *s)
_strlen		proc near

s		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, ds
		mov	es, ax
		assume es:seg000
		mov	di, [bp+s]
		xor	ax, ax
		cld
		mov	cx, 0FFFFh
		repne scasb
		xchg	ax, cx
		not	ax
		dec	ax
		pop	di
		pop	si
		pop	bp
		retn
_strlen		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl __write(int handle, void *buf, unsigned int len)
___write	proc near

var_8A		= byte ptr -8Ah
var_8		= word ptr -8
var_5		= byte ptr -5
var_4		= word ptr -4
var_2		= word ptr -2
handle		= word ptr  4
_buf		= word ptr  6
len		= word ptr  8

		push	bp
		mov	bp, sp
		sub	sp, 8Ah
		push	si
		push	di
		mov	ax, [bp+handle]
		cmp	ax, word_1914
		jb	short loc_12B4
		mov	ax, 6
		push	ax
		call	__IOERROR
		jmp	loc_13B7
; ---------------------------------------------------------------------------

loc_12B4:
		mov	ax, [bp+len]
		inc	ax
		cmp	ax, 2
		jnb	short loc_12C2
		xor	ax, ax
		jmp	loc_13B7
; ---------------------------------------------------------------------------

loc_12C2:
		mov	bx, [bp+handle]
		add	bx, bx
		test	byte ptr (word_1916+1)[bx], 8
		jz	short loc_12DF
		mov	ax, 2
		push	ax		; fromwhere
		xor	ax, ax
		push	ax
		push	ax		; offset
		push	[bp+handle]	; handle
		call	_lseek
		add	sp, 8

loc_12DF:
		mov	bx, [bp+handle]
		add	bx, bx
		test	byte ptr (word_1916+1)[bx], 40h
		jnz	short loc_12FD
		push	[bp+len]	; len
		push	[bp+_buf]	; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		jmp	loc_13B7
; ---------------------------------------------------------------------------

loc_12FD:
		mov	bx, [bp+handle]
		add	bx, bx
		and	word_1916[bx], 0FDFFh
		mov	ax, [bp+_buf]
		mov	[bp+var_8], ax
		mov	ax, [bp+len]
		mov	[bp+var_4], ax
		jmp	short loc_136F
; ---------------------------------------------------------------------------

loc_1316:
		dec	[bp+var_4]
		mov	bx, [bp+var_8]
		inc	[bp+var_8]
		mov	al, [bx]
		mov	[bp+var_5], al
		cmp	al, 0Ah
		jnz	short loc_132E
		mov	bx, cx
		mov	byte ptr [bx], 0Dh
		inc	cx

loc_132E:
		mov	bx, cx
		mov	al, [bp+var_5]
		mov	[bx], al
		inc	cx
		lea	ax, [bp+var_8A]
		mov	dx, cx
		sub	dx, ax
		cmp	dx, 80h
		jl	short loc_1373
		mov	dx, cx
		sub	dx, ax
		mov	[bp+var_2], dx
		push	dx		; len
		push	ax		; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		mov	dx, ax
		cmp	ax, [bp+var_2]
		jz	short loc_136F
		cmp	dx, 0FFFFh
		jnz	short loc_1367
		mov	ax, 0FFFFh
		jmp	short loc_13B2
; ---------------------------------------------------------------------------

loc_1367:
		mov	ax, [bp+len]
		sub	ax, [bp+var_4]
		jmp	short loc_13AD
; ---------------------------------------------------------------------------

loc_136F:
		lea	cx, [bp+var_8A]

loc_1373:
		cmp	[bp+var_4], 0
		jnz	short loc_1316
		lea	ax, [bp+var_8A]
		mov	dx, cx
		sub	dx, ax
		mov	[bp+var_2], dx
		mov	ax, dx
		or	ax, ax
		jbe	short loc_13B4
		push	dx		; len
		lea	ax, [bp+var_8A]
		push	ax		; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		mov	dx, ax
		cmp	ax, [bp+var_2]
		jz	short loc_13B4
		cmp	dx, 0FFFFh
		jnz	short loc_13AA
		mov	ax, 0FFFFh
		jmp	short loc_13B2
; ---------------------------------------------------------------------------

loc_13AA:
		mov	ax, [bp+len]

loc_13AD:
		add	ax, dx
		sub	ax, [bp+var_2]

loc_13B2:
		jmp	short loc_13B7
; ---------------------------------------------------------------------------

loc_13B4:
		mov	ax, [bp+len]

loc_13B7:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
___write	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl _rtl_write(int handle, const void	*buf, unsigned int len)
__rtl_write	proc near

handle		= word ptr  4
_buf		= word ptr  6
len		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	bx, [bp+handle]
		add	bx, bx
		test	byte ptr word_1916[bx],	1
		jz	short loc_13D4
		mov	ax, 5
		push	ax
		jmp	short loc_13F3
; ---------------------------------------------------------------------------

loc_13D4:
		mov	ah, 40h
		mov	bx, [bp+handle]
		mov	cx, [bp+len]
		mov	dx, [bp+_buf]
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		jb	short loc_13F2
		push	ax
		mov	bx, [bp+handle]
		add	bx, bx
		or	word_1916[bx], 1000h
		pop	ax
		jmp	short loc_13F6
; ---------------------------------------------------------------------------

loc_13F2:
		push	ax

loc_13F3:
		call	__IOERROR

loc_13F6:
		pop	di
		pop	si
		pop	bp
		retn
__rtl_write	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl _write(int handle, const void *buf, unsigned int len)
__write		proc near

handle		= word ptr  4
_buf		= word ptr  6
len		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+len]	; len
		push	[bp+_buf]	; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		pop	di
		pop	si
		pop	bp
		retn
__write		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

__xfflush	proc near

var_4		= word ptr -4
_stream		= word ptr -2

		push	bp
		mov	bp, sp
		sub	sp, 4
		push	si
		push	di
		mov	[bp+var_4], 4
		mov	[bp+_stream], offset stream
		jmp	short loc_143B
; ---------------------------------------------------------------------------

loc_1426:
		mov	bx, [bp+_stream]
		test	byte ptr [bx+2], 3
		jz	short loc_1434
		push	bx		; stream
		call	_fflush
		pop	cx

loc_1434:
		dec	[bp+var_4]
		add	[bp+_stream], 10h

loc_143B:
		cmp	[bp+var_4], 0
		jnz	short loc_1426
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
__xfflush	endp

; ---------------------------------------------------------------------------
word_1447	dw 0

; =============== S U B	R O U T	I N E =======================================

; BCC v4.x/5.x DOS runtime
; Attributes: library function

unknown_libname_1 proc near

; FUNCTION CHUNK AT 152F SIZE 00000059 BYTES

		pop	word_19BE
		pop	word_19C0
		pop	word_19C2
		mov	cs:word_1447, ds
		mov	word_19C4, si
		mov	word_19C6, di
		cld
		mov	es, word_15E6
		assume es:nothing
		mov	si, 80h
		xor	ah, ah
		lods	byte ptr es:[si]
		inc	ax
		mov	bp, es
		xchg	dx, si
		xchg	ax, bx
		mov	si, word_15E0
		inc	si
		inc	si
		mov	cx, 1
		cmp	byte ptr word_15E8, 3
		jb	short loc_1495
		mov	es, word_15E2
		mov	di, si
		mov	cl, 7Fh
		xor	al, al
		repne scasb
		jcxz	short loc_14DC
		xor	cl, 7Fh

loc_1495:
		push	ax
		mov	ax, cx
		add	ax, bx
		inc	ax
		and	ax, 0FFFEh
		mov	di, sp
		sub	di, ax
		jb	short loc_14DC
		mov	sp, di
		push	es
		pop	ds
		push	ss
		pop	es
		push	cx
		dec	cx
		rep movsb
		xor	al, al
		stosb
		mov	ds, bp
		xchg	si, dx
		xchg	bx, cx
		mov	ax, bx
		mov	dx, ax
		inc	bx

loc_14BC:
		call	sub_14DF
		ja	short loc_14CC

loc_14C1:
		jb	short loc_152F
		cmp	al, 0Dh
		jz	short loc_14D8
		call	sub_14DF
		ja	short loc_14C1

loc_14CC:
		cmp	al, 20h
		jz	short loc_14D8
		cmp	al, 0Dh
		jz	short loc_14D8
		cmp	al, 9
		jnz	short loc_14BC

loc_14D8:
		xor	al, al
		jmp	short loc_14BC
; ---------------------------------------------------------------------------

loc_14DC:
		jmp	sub_91C
unknown_libname_1 endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================


sub_14DF	proc near
		or	ax, ax
		jz	short loc_14EA
		inc	dx
		stosb
		or	al, al
		jnz	short loc_14EA
		inc	bx

loc_14EA:
		xchg	ah, al
		xor	al, al
		stc
		jcxz	short locret_152E
		lodsb
		dec	cx
		cmp	dh, 1
		jz	short loc_1514
		xor	dh, dh
		push	ax
		push	bx
		push	cx
		push	dx
		push	ds
		push	es
		mov	ds, cs:word_1447
		push	ax
		call	sub_EA1
		or	ax, ax
		pop	cx
		pop	es
		pop	ds
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jz	short loc_1516

loc_1514:
		inc	dh

loc_1516:
		cmp	dh, 0
		jnz	short loc_152C
		sub	al, 22h
		jz	short locret_152E
		add	al, 22h
		cmp	al, 5Ch
		jnz	short loc_152C
		cmp	byte ptr [si], 22h
		jnz	short loc_152C
		lodsb
		dec	cx

loc_152C:
		or	si, si

locret_152E:
		retn
sub_14DF	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR unknown_libname_1

loc_152F:
		pop	cx
		xor	dh, dh
		add	cx, dx
		mov	ds, cs:word_1447
		mov	word_19BA, bx
		inc	bx
		add	bx, bx
		mov	si, sp
		mov	bp, sp
		sub	bp, bx
		jb	short loc_14DC
		mov	sp, bp
		mov	word_19BC, bp

loc_154E:
		jcxz	short loc_155E
		mov	[bp+0],	si
		add	bp, 2

loc_1556:
		lods	byte ptr ss:[si]
		or	al, al
		loopne	loc_1556
		jz	short loc_154E

loc_155E:
		xor	ax, ax
		mov	[bp+0],	ax
		mov	ds, cs:word_1447
		mov	si, word_19C4
		mov	di, word_19C6
		push	word_19C2
		push	word_19C0
		mov	ax, word_19BA
		mov	argc, ax
		mov	ax, word_19BC
		mov	argv, ax
		jmp	word_19BE
; END OF FUNCTION CHUNK	FOR unknown_libname_1
; ---------------------------------------------------------------------------
		db 8 dup(0)
aBorlandCCopyri	db 'Borland C++ - Copyright 1993 Borland Intl.',0
; char buf[]
buf		db 'Divide error',0Dh,0Ah,0
dword_15CA	dd 0
dword_15CE	dd 0
dword_15D2	dd 0
dword_15D6	dd 0
; int argc
argc		dw 0
; char **argv
argv		dw 0
; char **envp
envp		dw 0
word_15E0	dw 0
word_15E2	dw 0
word_15E4	dw 0
word_15E6	dw 0
word_15E8	dw 0
word_15EA	dw 0
		dw 0FFFFh
		dw offset edata@
off_15F0	dw offset edata@
		dw 0
word_15F4	dw 0
		dw 0
word_15F8	dw 0
		dw 0
word_15FC	dw 0
byte_15FE	db 0
unk_15FF	db 0FFh
		db    3
		db    2
		db    1
		db    1
		db    1
aMiko_cfg	db 'miko.cfg',0
aHumaconfig	db 'HUMAConfig',0
aUmx		db 0Ah
		db 0Ah
		db '東方幻想郷用　 常駐プログラム　RES_HUMA.com Version1.00       (c)zun 1998',0Ah,0
aVavVBavVVvvVV	db 'わたし、まだいませんよぉ',0Ah
		db 0Ah,0
aVVcvVcbavVIqvj	db 'さよなら、また会えたらいいな',0Ah
		db 0Ah,0
aVV		db 'そんなオプション付けられても、困るんですけど',0Ah
		db 0Ah,0
aVavVBavVVVvvVV	db 'わたし、すでにいますよぉ',0Ah
		db 0Ah,0
aNVVVV		db '作れません、わたしの居場所がないの！',0Ah
		db 0Ah,0
aVVVVBavcvivVnv	db 'それでは、よろしくお願いします',0Ah
		db 0Ah,0
aMasters_libVer	db 'MASTERS.LIB Version 0.23 Copyright (c)1995 A.Koizuka,Kazumi,steelman,iR,All rights reserved.',0
		db 0
word_1790	dw 0A800h
word_1792	dw 3E80h
		db 90h
		db 1
		dw 50h
		dw 0
		dw 55h
aPal98Grb	db 'pal98 grb',0
word_17A6	dw 0
word_17A8	dw 0FFFFh
byte_17AA	db 0
		db 0
aAbnormalProgra	db 'Abnormal program termination',0Dh,0Ah,0
		db 0
word_17CC	dw 0
off_17CE	dw offset sub_978
off_17D0	dw offset sub_978
off_17D2	dw offset sub_978
; FILE stream
stream		FILE <0, 209h, 0, 0, 0,	0, 0, 0, offset	stream>
stru_17E4	FILE <0, 20Ah, 1, 0, 0,	0, 0, 0, offset	stru_17E4>
stru_17F4	FILE <0, 202h, 2, 0, 0,	0, 0, 0, offset	stru_17F4>
stru_1804	FILE <0, 243h, 3, 0, 0,	0, 0, 0, offset	stru_1804>
stru_1814	FILE <0, 242h, 4, 0, 0,	0, 0, 0, offset	stru_1814>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
word_1914	dw 14h
word_1916	dw 6001h,6002h,6002h,0A004h,0A002h,0,0,0,0,0,0,0,0,0,0
		dw 0,0,0,0,0
word_193E	dw 0
word_1940	dw 0
byte_1942	db 0
		db  13h
		db    2
		db    2
		db    4
		db    5
		db    6
		db    8
		db    8
		db    8
		db  14h
		db  15h
		db    5
		db  13h
		db  0Eh
		db    5
		db    5
		db  11h
		db    2
		db  1Eh
		db  29h	; )
		db  2Ch	; ,
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  29h	; )
		db  2Ch	; ,
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db    5
		db    5
		db  29h	; )
		db  17h
		db  17h
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Fh
		db  2Ch	; ,
		db  23h	; #
		db    2
		db  2Ch	; ,
		db  0Fh
		db  2Ah	; *
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  13h
		db  1Bh
		db  1Ch
		db    2
		db    2
		db    5
		db  0Fh
		db    2
		db  17h
		db  28h	; (
		db  2Ah	; *
		db  13h
		db  2Ah	; *
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  23h	; #
		db  0Eh
		db  1Ch
		db  28h	; (
		db  17h
		db  23h	; #
		db  25h	; %
		db  13h
		db  28h	; (
		db    0
word_199C	dw 1000h
word_199E	dw 0
word_19A0	dw 0
word_19A2	dw 0
dword_19A4	dd 0
byte_19A8	db 0Ch dup(0)
word_19B4	dw 0
word_19B6	dw 0
word_19B8	dw 30h
word_19BA	dw 0
word_19BC	dw 0
word_19BE	dw 0
word_19C0	dw 0
word_19C2	dw 0
word_19C4	dw 0
word_19C6	dw 0
InitStart	db    0
		db    2
		dw offset __setupio
		db    0
		db    0
		db    0
		db 0Fh
		dw offset sub_E59
		db    0
		db    0
		db    0
		db  10h
		dw offset unknown_libname_1 ; BCC v4.x/5.x DOS runtime
		dw ?
bdata@		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
unk_19DE	db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
word_19E2	dw ?
word_19E4	dw ?
word_19E6	dw ?
unk_19E8	db    ?	;
		db    ?	;
unk_19EA	db    ?	;
		db    ?	;
unk_19EC	db    ?	;
		db    ?	;
word_19EE	dw ?
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
edata@	label byte
seg000		ends


		end start

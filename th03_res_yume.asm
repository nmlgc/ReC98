; ---------------------------------------------------------------------------

FILE		struc ;	(sizeof=0x10, standard type)
level		dw ?
flags		dw ?
fd		db ?
hold		db ?
bsize		dw ?
buffer		dw ?			; offset
curp		dw ?			; offset
istemp		dw ?
token		dw ?			; offset
FILE		ends


;
; +-------------------------------------------------------------------------+
; |   This file has been generated by The Interactive Disassembler (IDA)    |
; |        Copyright (c) 2009 by Hex-Rays, <support@hex-rays.com>           |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	4E0826B310EA5A6F9DE4C37E09626566

; File Name   :	th03/ZUN.COM:RES_YUME (-5)
; Format      :	MS-DOS COM-file
; Base Address:	0h Range: 100h-16F2h Loaded length: 15F2h
; OS type	  :  MS	DOS
; Application type:  Executable	16bit

		.386
		.model tiny

; ===========================================================================

; Segment type:	Pure code
seg000		segment	byte public 'CODE' use16
		assume cs:seg000
		org 100h
		assume es:nothing, ss:nothing, ds:seg000, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn

		public start
start		proc near
		mov	dx, cs
		mov	cs:DGROUP@, dx
		mov	ah, 30h
		int	21h		; DOS -	GET DOS	VERSION
					; Return: AL = major version number (00h for DOS 1.x)
		mov	bp, ds:2
		mov	bx, ds:2Ch
		mov	ds, dx
		mov	word_1308, ax
		mov	word_1306, es
		mov	word_1302, bx
		mov	word_131C, bp
		call	sub_26E
		mov	ax, word_1302
		mov	es, ax
		xor	ax, ax
		mov	bx, ax
		mov	di, ax
		mov	cx, 7FFFh
		cld

loc_136:
		repne scasb
		jcxz	short loc_19B
		inc	bx
		cmp	es:[di], al
		jnz	short loc_136
		or	ch, 80h
		neg	cx
		mov	word_1300, cx
		mov	cx, 1
		shl	bx, cl
		add	bx, 8
		and	bx, 0FFF8h
		mov	word_1304, bx
		mov	dx, ds
		sub	bp, dx
		mov	di, word_16B6
		cmp	di, 200h
		jnb	short loc_16D
		mov	di, 200h
		mov	word_16B6, di

loc_16D:
		add	di, offset edata@
		jb	short loc_19B
		add	di, word_1658
		jb	short loc_19B
		mov	cl, 4
		shr	di, cl
		inc	di
		cmp	bp, di
		jb	short loc_19B
		cmp	word_16B6, 0
		jz	short loc_190
		cmp	word_1658, 0
		jnz	short loc_19E

loc_190:
		mov	di, 1000h
		cmp	bp, di
		ja	short loc_19E
		mov	di, bp
		jmp	short loc_19E
; ---------------------------------------------------------------------------

loc_19B:
		call	sub_63A
; ---------------------------------------------------------------------------

loc_19E:
		mov	bx, di
		add	bx, dx
		mov	word_1314, bx
		mov	word_1318, bx
		mov	ax, word_1306
		sub	bx, ax
		mov	es, ax
		mov	ah, 4Ah
		push	di
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		pop	di
		shl	di, cl
		cli
		mov	ss, dx
		mov	sp, di
		sti
		xor	ax, ax
		mov	es, cs:DGROUP@
		mov	di, offset bdata@
		mov	cx, offset edata@
		sub	cx, di
		cld
		rep stosb
		cmp	word_162E, 14h
		jbe	short loc_21F
		cmp	byte ptr word_1308, 3
		jb	short loc_21F
		ja	short loc_1E8
		cmp	byte ptr word_1308+1, 1Eh
		jb	short loc_21F

loc_1E8:
		mov	ax, 5801h
		mov	bx, 2
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		jb	short loc_21C
		mov	ah, 67h
		mov	bx, word_162E
		int	21h		; DOS -	3.3+ - SET HANDLE COUNT
					; BX = desired number of handles (max 255)
		jb	short loc_21C
		mov	ah, 48h
		mov	bx, 1
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short loc_21C
		inc	ax
		mov	word_131C, ax
		dec	ax
		mov	es, ax
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		jb	short loc_21C
		mov	ax, 5801h
		mov	bx, 0
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		jnb	short loc_21F

loc_21C:
		call	sub_63A
; ---------------------------------------------------------------------------

loc_21F:
		xor	bp, bp
		mov	es, cs:DGROUP@
		assume es:nothing
		mov	si, offset InitStart
		mov	di, offset bdata@
		call	sub_2DE
		push	envp		; envp
		push	argv		; argv
		push	argc		; argc
		call	_main
		push	ax		; status
		call	_exit
; ---------------------------------------------------------------------------

__cleanup:
		mov	es, cs:DGROUP@
		push	si
		push	di
		mov	si, offset bdata@
		mov	di, offset bdata@
		call	sub_322
		pop	di
		pop	si
		retn
start		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

__checknull	proc near
		retn
__checknull	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn	bp-based frame

__terminate	proc near

arg_0		= byte ptr  2

		mov	bp, sp
		mov	ah, 4Ch
		mov	al, [bp+arg_0]
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
__terminate	endp			; AL = exit code


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn

sub_25F		proc near
		mov	dx, offset buf	; "Divide error\r\n"
		push	dx		; buf
		call	___ErrorMessage
		pop	dx
		mov	ax, 3
		push	ax		; status
		call	__exit
sub_25F		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_26E		proc near
		push	ds
		mov	ax, 3500h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_12EA, bx
		mov	word ptr dword_12EA+2, es
		mov	ax, 3504h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_12EE, bx
		mov	word ptr dword_12EE+2, es
		mov	ax, 3505h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_12F2, bx
		mov	word ptr dword_12F2+2, es
		mov	ax, 3506h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr dword_12F6, bx
		mov	word ptr dword_12F6+2, es
		mov	ax, 2500h
		mov	dx, cs
		mov	ds, dx
		mov	dx, offset sub_25F
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		retn
sub_26E		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

__restorezero	proc near
		push	ds
		mov	ax, 2500h
		lds	dx, dword_12EA
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		push	ds
		mov	ax, 2504h
		lds	dx, dword_12EE
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		push	ds
		mov	ax, 2505h
		lds	dx, dword_12F2
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		push	ds
		mov	ax, 2506h
		lds	dx, dword_12F6
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		retn
__restorezero	endp


; =============== S U B	R O U T	I N E =======================================


sub_2DE		proc near
		mov	ax, 100h
		mov	dx, di
		mov	bx, si

loc_2E5:
		cmp	bx, di
		jz	short loc_302
		cmp	byte ptr es:[bx], 0FFh
		jz	short loc_2FD
		mov	cl, es:[bx+1]
		xor	ch, ch
		cmp	cx, ax
		jnb	short loc_2FD
		mov	ax, cx
		mov	dx, bx

loc_2FD:
		add	bx, 6
		jmp	short loc_2E5
; ---------------------------------------------------------------------------

loc_302:
		cmp	dx, di
		jz	short locret_321
		mov	bx, dx
		cmp	byte ptr es:[bx], 0
		mov	byte ptr es:[bx], 0FFh
		push	es
		jz	short loc_31A
		call	dword ptr es:[bx+2]
		pop	es
		jmp	short sub_2DE
; ---------------------------------------------------------------------------

loc_31A:
		call	word ptr es:[bx+2]
		pop	es
		jmp	short sub_2DE
; ---------------------------------------------------------------------------

locret_321:
		retn
sub_2DE		endp


; =============== S U B	R O U T	I N E =======================================


sub_322		proc near
		mov	ah, 0
		mov	dx, di
		mov	bx, si

loc_328:
		cmp	bx, di
		jz	short loc_343
		cmp	byte ptr es:[bx], 0FFh
		jz	short loc_33E
		cmp	es:[bx+1], ah
		jb	short loc_33E
		mov	ah, es:[bx+1]
		mov	dx, bx

loc_33E:
		add	bx, 6
		jmp	short loc_328
; ---------------------------------------------------------------------------

loc_343:
		cmp	dx, di
		jz	short locret_362
		mov	bx, dx
		cmp	byte ptr es:[bx], 0
		mov	byte ptr es:[bx], 0FFh
		push	es
		jz	short loc_35B
		call	dword ptr es:[bx+2]
		pop	es
		jmp	short sub_322
; ---------------------------------------------------------------------------

loc_35B:
		call	word ptr es:[bx+2]
		pop	es
		jmp	short sub_322
; ---------------------------------------------------------------------------

locret_362:
		retn
sub_322		endp

; ---------------------------------------------------------------------------
DGROUP@		dw 0
__MMODEL	db 2 dup(0)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_367		proc near

var_6		= byte ptr -6
arg_0		= byte ptr  4

		enter	6, 0
		push	si
		push	di
		mov	di, offset aYume_cfg ; "yume.cfg"
		lea	ax, [bp+var_6]
		push	ss
		push	ax
		push	ds
		push	offset unk_131F
		mov	cx, 5
		call	N_SCOPY@
		push	3D02h
		push	di
		call	sub_59C
		mov	si, ax
		or	si, si
		jle	short loc_398
		push	ax
		push	0
		push	5
		push	0
		call	sub_61E
		jmp	short loc_3AB
; ---------------------------------------------------------------------------

loc_398:
		push	di
		push	20h
		call	sub_5B2
		mov	si, ax
		push	ax
		push	ss
		lea	ax, [bp+var_6]
		push	ax
		push	5
		call	sub_604

loc_3AB:
		push	si
		push	ss
		lea	ax, [bp+arg_0]
		push	ax
		push	2
		call	sub_604
		push	si
		push	ds
		push	offset byte_131E
		push	1
		call	sub_604
		push	si
		call	sub_5EE
		pop	di
		pop	si
		leave
		retn
sub_367		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
_main		proc near

var_8		= dword	ptr -8
var_4		= word ptr -4
var_2		= word ptr -2
_argc		= word ptr  4
_argv		= word ptr  6
_envp		= word ptr  8

		enter	8, 0
		push	si
		push	di
		mov	si, [bp+_argv]
		mov	[bp+var_2], offset aYumeconfig ; "YUMEConfig"
		push	[bp+var_2]
		push	0Ah
		push	10h
		call	sub_4CE
		mov	di, ax
		push	offset aUmx	; "\n\n東方夢時空用　 常駐プログラム　RES_YU"...
		call	sub_5C6
		call	sub_4AA
		cmp	[bp+_argc], 2
		jnz	short loc_44E
		mov	bx, [si+2]
		cmp	byte ptr [bx], 2Dh
		jz	short loc_3FE
		cmp	byte ptr [bx], 2Fh
		jnz	short loc_423

loc_3FE:
		mov	bx, [si+2]
		cmp	byte ptr [bx+1], 52h
		jz	short loc_40D
		cmp	byte ptr [bx+1], 72h
		jnz	short loc_423

loc_40D:
		or	di, di
		jnz	short loc_416
		push	offset aVavVBavVVvvVV ;	"わたし、まだいませんよぉ\n\n"
		jmp	short loc_46D
; ---------------------------------------------------------------------------

loc_416:
		push	di
		call	sub_58C
		push	offset aVVcvVcbavVIqvj ; "さよなら、また会えたらいいな\n\n"
		call	sub_5C6
		jmp	loc_4A3
; ---------------------------------------------------------------------------

loc_423:
		mov	bx, [si+2]
		cmp	byte ptr [bx], 2Dh
		jz	short loc_430
		cmp	byte ptr [bx], 2Fh
		jnz	short loc_446

loc_430:
		mov	bx, [si+2]
		cmp	byte ptr [bx+1], 44h
		jz	short loc_43F
		cmp	byte ptr [bx+1], 64h
		jnz	short loc_446

loc_43F:
		mov	byte_131E, 1
		jmp	short loc_44E
; ---------------------------------------------------------------------------

loc_446:
		push	offset aVV	; "そんなオプション付けられても、困るんで・...
		call	sub_5C6
		jmp	short loc_470
; ---------------------------------------------------------------------------

loc_44E:
		or	di, di
		jz	short loc_45A
		push	offset aVavVBavVVVvvVV ; "わたし、すでにいますよぉ\n\n"
		call	sub_5C6
		jmp	short loc_470
; ---------------------------------------------------------------------------

loc_45A:
		push	[bp+var_2]
		push	0Ah
		push	10h
		call	sub_516
		mov	di, ax
		or	di, di
		jnz	short loc_475
		push	offset aNVVVV	; "作れません、わたしの居場所がないの！\n\n"

loc_46D:
		call	sub_5C6

loc_470:
		mov	ax, 1
		jmp	short loc_4A5
; ---------------------------------------------------------------------------

loc_475:
		mov	word ptr [bp+var_8+2], di
		mov	word ptr [bp+var_8], 0
		push	offset aVVVVBavcvivVnv ; "それでは、よろしくお願いします\n\n"
		call	sub_5C6
		mov	[bp+var_4], 0Bh
		jmp	short loc_497
; ---------------------------------------------------------------------------

loc_48A:
		les	bx, [bp+var_8]
		add	bx, [bp+var_4]
		mov	byte ptr es:[bx], 0
		inc	[bp+var_4]

loc_497:
		cmp	[bp+var_4], 100h
		jl	short loc_48A
		push	di
		call	sub_367
		pop	cx

loc_4A3:
		xor	ax, ax

loc_4A5:
		pop	di
		pop	si
		leave
		retn
_main		endp

; ---------------------------------------------------------------------------
		db 0

; =============== S U B	R O U T	I N E =======================================


sub_4AA		proc near
		mov	al, 80h
		pushf
		cli
		out	7Ch, al
		popf
		xor	ax, ax
		mov	dx, 7Eh
		out	dx, al
		out	dx, al
		out	dx, al
		out	dx, al
		mov	bx, di
		xor	di, di
		mov	cx, word_14B2
		mov	es, word_14B0
		assume es:nothing
		rep stosw
		mov	di, bx
		out	7Ch, al
		retn
sub_4AA		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_4CE		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ah, 52h
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		cld
		mov	bx, es:[bx-2]

loc_4DC:
		mov	es, bx
		assume es:nothing
		inc	bx
		mov	ax, es:1
		or	ax, ax
		jz	short loc_4FD
		mov	ax, es:3
		cmp	ax, [bp+arg_0]
		jnz	short loc_4FD
		mov	cx, [bp+arg_2]
		mov	si, [bp+arg_4]
		mov	di, 10h
		repe cmpsb
		jz	short loc_50E

loc_4FD:
		mov	ax, es:3
		add	bx, ax
		mov	al, es:0
		cmp	al, 4Dh
		jz	short loc_4DC
		mov	bx, 0

loc_50E:
		mov	ax, bx
		pop	di
		pop	si
		pop	bp
		retn	6
sub_4CE		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_516		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+arg_4]
		push	[bp+arg_2]
		push	[bp+arg_0]
		call	sub_4CE
		or	ax, ax
		jnz	short loc_585
		mov	ax, 5800h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: get allocation strategy
		mov	dx, ax
		mov	ax, 5801h
		mov	bx, 1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	ah, 48h
		mov	bx, [bp+arg_0]
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	cx, 0
		jb	short loc_57C
		mov	bx, cs
		cmp	bx, ax
		jnb	short loc_561
		mov	es, ax
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	ax, 5801h
		mov	bx, 2
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	ah, 48h
		mov	bx, [bp+arg_0]
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired

loc_561:
		mov	cx, ax
		push	ax
		dec	cx
		mov	es, cx
		assume es:nothing
		mov	ax, 0FFFFh
		mov	es:1, ax
		inc	cx
		mov	es, cx
		assume es:nothing
		xor	di, di
		mov	cx, [bp+arg_2]
		mov	si, [bp+arg_4]
		rep movsb
		pop	cx

loc_57C:
		mov	ax, 5801h
		mov	bx, dx
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	ax, cx

loc_585:
		pop	di
		pop	si
		pop	bp
		retn	6
sub_516		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_58C		proc near

arg_0		= word ptr  6

		push	bp
		push	es
		mov	bp, sp
		mov	es, [bp+arg_0]
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es
		pop	bp
		retn	2
sub_58C		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_59C		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6

		push	bp
		mov	bp, sp
		mov	dx, [bp+arg_0]
		mov	ax, [bp+arg_2]
		int	21h		; DOS -
		sbb	dx, dx
		xor	ax, dx
		sub	ax, dx
		pop	bp
		retn	4
sub_59C		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_5B2		proc near
		mov	bx, sp
		mov	ax, 3C00h
		push	ax
		push	word ptr ss:[bx+4]
		mov	cx, ss:[bx+2]
		call	sub_59C
		retn	4
sub_5B2		endp


; =============== S U B	R O U T	I N E =======================================


sub_5C6		proc near
		mov	bx, sp
		mov	cx, si
		mov	si, ss:[bx+2]
		lodsb
		or	al, al
		jz	short loc_5E8
		mov	ah, 2

loc_5D5:
		cmp	al, 0Ah
		jnz	short loc_5DF
		mov	dl, 0Dh
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		mov	al, 0Ah

loc_5DF:
		mov	dl, al
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		lodsb
		or	al, al
		jnz	short loc_5D5

loc_5E8:
		mov	si, cx
		retn	2
sub_5C6		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================


sub_5EE		proc near
		mov	bx, sp
		mov	ah, 3Eh
		mov	bx, ss:[bx+2]
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	ax, 0
		jnb	short locret_600
		mov	ax, 0FFF3h

locret_600:
		retn	2
sub_5EE		endp

; ---------------------------------------------------------------------------
		nop

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_604		proc near

arg_0		= word ptr  4
arg_2		= dword	ptr  6
arg_6		= word ptr  0Ah

		push	bp
		mov	bp, sp
		push	ds
		mov	bx, [bp+arg_6]
		lds	dx, [bp+arg_2]
		mov	cx, [bp+arg_0]
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	ds
		jnb	short loc_61A
		neg	ax

loc_61A:
		pop	bp
		retn	8
sub_604		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_61E		proc near

arg_0		= byte ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8
arg_6		= word ptr  0Ah

		push	bp
		mov	bp, sp
		mov	bx, [bp+arg_6]
		mov	dx, [bp+arg_2]
		mov	cx, [bp+arg_4]
		mov	al, [bp+arg_0]
		mov	ah, 42h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method:
					; 0-from beginnig,1-from current,2-from	end
		jnb	short loc_636
		neg	ax
		cwd

loc_636:
		pop	bp
		retn	8
sub_61E		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

sub_63A		proc near
		push	si
		push	di
		mov	ax, offset aAbnormalProgra ; "Abnormal program termination\r\n"
		push	ax		; buf
		call	___ErrorMessage
		mov	ax, 3
		push	ax		; status
		call	__exit
; ---------------------------------------------------------------------------
		pop	cx
		pop	cx
		pop	di
		pop	si
		retn
sub_63A		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl atexit(void (*func)(void))
_atexit		proc near

func		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		cmp	word_14E6, 20h
		jnz	short loc_660
		mov	ax, 1
		jmp	short loc_673
; ---------------------------------------------------------------------------

loc_660:
		mov	bx, word_14E6
		add	bx, bx
		mov	ax, [bp+func]
		mov	[bx+16F4h], ax
		inc	word_14E6
		xor	ax, ax

loc_673:
		pop	di
		pop	si
		pop	bp
		retn
_atexit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl __ErrorMessage(char *buf)
___ErrorMessage	proc near

_buf		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+_buf]	; s
		call	_strlen
		pop	cx
		push	ax		; len
		push	[bp+_buf]	; buf
		mov	al, stru_150E.fd
		cbw
		push	ax		; handle
		call	__rtl_write
		add	sp, 6
		pop	di
		pop	si
		pop	bp
		retn
___ErrorMessage	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_696		proc near
		push	si
		push	di
		pop	di
		pop	si
		retn
sub_696		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

sub_69B		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		cmp	[bp+arg_4], 0
		jnz	short loc_6C4
		jmp	short loc_6B6
; ---------------------------------------------------------------------------

loc_6A8:
		dec	word_14E6
		mov	bx, word_14E6
		add	bx, bx
		call	word ptr [bx+16F4h]

loc_6B6:
		cmp	word_14E6, 0
		jnz	short loc_6A8
		call	__cleanup
		call	off_14E8

loc_6C4:
		call	__restorezero
		call	__checknull
		cmp	[bp+arg_2], 0
		jnz	short loc_6E5
		cmp	[bp+arg_4], 0
		jnz	short loc_6DE
		call	off_14EA
		call	off_14EC

loc_6DE:
		push	[bp+arg_0]
		call	__terminate
; ---------------------------------------------------------------------------
		pop	cx

loc_6E5:
		pop	di
		pop	si
		pop	bp
		retn	6
sub_69B		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn	bp-based frame

; void __cdecl exit(int	status)
_exit		proc near

status		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		xor	ax, ax
		push	ax
		push	ax
		push	[bp+status]
		call	sub_69B
		pop	di
		pop	si
		pop	bp
		retn
_exit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function noreturn	bp-based frame

; void __cdecl _exit(int status)
__exit		proc near

status		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, 1
		push	ax
		xor	ax, ax
		push	ax
		push	[bp+status]
		call	sub_69B
		pop	di
		pop	si
		pop	bp
		retn
__exit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void _cexit(void)
__cexit		proc near
		push	si
		push	di
		xor	ax, ax
		push	ax
		mov	ax, 1
		push	ax
		xor	ax, ax
		push	ax
		call	sub_69B
		pop	di
		pop	si
		retn
__cexit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void _c_exit(void)
__c_exit	proc near
		push	si
		push	di
		mov	ax, 1
		push	ax
		push	ax
		xor	ax, ax
		push	ax
		call	sub_69B
		pop	di
		pop	si
		retn
__c_exit	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

__IOERROR	proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	dx, [bp+arg_0]
		or	dx, dx
		jl	short loc_759
		cmp	dx, 58h
		jle	short loc_74A

loc_747:
		mov	dx, 57h

loc_74A:
		mov	word_165A, dx
		mov	bx, dx
		mov	al, byte_165C[bx]
		cbw
		mov	dx, ax
		jmp	short loc_767
; ---------------------------------------------------------------------------

loc_759:
		neg	dx
		cmp	dx, word_16D2
		jg	short loc_747
		mov	word_165A, 0FFFFh

loc_767:
		mov	word_130A, dx
		mov	ax, 0FFFFh
		pop	di
		pop	si
		pop	bp
		retn	2
__IOERROR	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

__DOSERROR	proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+arg_0]
		call	__IOERROR
		mov	ax, [bp+arg_0]
		pop	di
		pop	si
		pop	bp
		retn	2
__DOSERROR	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl isatty(int handle)
_isatty		proc near

handle		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, 4400h
		mov	bx, [bp+handle]
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		xchg	ax, dx
		and	ax, 80h
		pop	di
		pop	si
		pop	bp
		retn
_isatty		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; __int32 __cdecl lseek(int handle, __int32 offset, int	fromwhere)
_lseek		proc near

handle		= word ptr  4
_offset		= word ptr  6
arg_4		= word ptr  8
fromwhere	= byte ptr  0Ah

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	bx, [bp+handle]
		add	bx, bx
		and	word_1630[bx], 0FDFFh
		mov	ah, 42h
		mov	al, [bp+fromwhere]
		mov	bx, [bp+handle]
		mov	cx, [bp+arg_4]
		mov	dx, [bp+_offset]
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method:
					; 0-from beginnig,1-from current,2-from	end
		jb	short loc_7C1
		jmp	short loc_7C6
; ---------------------------------------------------------------------------

loc_7C1:
		push	ax
		call	__IOERROR
		cwd

loc_7C6:
		pop	di
		pop	si
		pop	bp
		retn
_lseek		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

N_SCOPY@	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	ds
		lds	si, [bp+arg_0]
		les	di, [bp+arg_4]
		cld
		shr	cx, 1
		rep movsw
		adc	cx, cx
		rep movsb
		pop	ds
		pop	di
		pop	si
		pop	bp
		retn	8
N_SCOPY@	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

__setupio	proc near
		push	si
		push	di
		mov	dx, 5
		jmp	short loc_812
; ---------------------------------------------------------------------------

loc_7ED:
		mov	bx, dx
		add	bx, bx
		mov	word_1630[bx], 0
		mov	bx, dx
		mov	cl, 4
		shl	bx, cl
		mov	stru_14EE.fd[bx], 0FFh
		mov	ax, dx
		shl	ax, cl
		add	ax, offset stru_14EE
		mov	bx, dx
		shl	bx, cl
		mov	stru_14EE.token[bx], ax
		inc	dx

loc_812:
		cmp	dx, word_162E
		jb	short loc_7ED
		mov	al, stru_14EE.fd
		cbw
		push	ax		; handle
		call	_isatty
		pop	cx
		or	ax, ax
		jnz	short loc_82B
		and	stru_14EE.flags, 0FDFFh

loc_82B:
		mov	ax, 200h
		push	ax		; size
		test	byte ptr stru_14EE.flags+1, 2
		jz	short loc_83B
		mov	ax, 1
		jmp	short loc_83D
; ---------------------------------------------------------------------------

loc_83B:
		xor	ax, ax

loc_83D:
		push	ax		; type
		xor	ax, ax
		push	ax		; buf
		mov	ax, offset stru_14EE
		push	ax		; stream
		call	_setvbuf
		add	sp, 8
		mov	al, stru_14FE.fd
		cbw
		push	ax		; handle
		call	_isatty
		pop	cx
		or	ax, ax
		jnz	short loc_85E
		and	stru_14FE.flags, 0FDFFh

loc_85E:
		mov	ax, 200h
		push	ax		; size
		test	byte ptr stru_14FE.flags+1, 2
		jz	short loc_86E
		mov	ax, 2
		jmp	short loc_870
; ---------------------------------------------------------------------------

loc_86E:
		xor	ax, ax

loc_870:
		push	ax		; type
		xor	ax, ax
		push	ax		; buf
		mov	ax, offset stru_14FE
		push	ax		; stream
		call	_setvbuf
		add	sp, 8
		pop	di
		pop	si
		retn
__setupio	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

___brk		proc near

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, [bp+arg_0]
		mov	dx, sp
		sub	dx, 200h
		cmp	ax, dx
		jnb	short loc_89A
		mov	off_1310, ax
		xor	ax, ax
		jmp	short loc_8A3
; ---------------------------------------------------------------------------

loc_89A:
		mov	word_130A, 8
		mov	ax, 0FFFFh

loc_8A3:
		pop	di
		pop	si
		pop	bp
		retn
___brk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

___sbrk		proc near

arg_0		= word ptr  4
arg_2		= word ptr  6

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, [bp+arg_0]
		mov	dx, [bp+arg_2]
		add	ax, off_1310
		adc	dx, 0
		mov	cx, ax
		or	dx, dx
		jnz	short loc_8CF
		add	cx, 200h
		jb	short loc_8CF
		cmp	cx, sp
		jnb	short loc_8CF
		xchg	ax, off_1310
		jmp	short loc_8D8
; ---------------------------------------------------------------------------

loc_8CF:
		mov	word_130A, 8
		mov	ax, 0FFFFh

loc_8D8:
		pop	di
		pop	si
		pop	bp
		retn
___sbrk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl brk(void *addr)
_brk		proc near

addr		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+addr]
		call	___brk
		pop	cx
		pop	di
		pop	si
		pop	bp
		retn
_brk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; void *__cdecl	sbrk(int incr)
_sbrk		proc near

incr		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, [bp+incr]
		cwd
		push	dx
		push	ax
		call	___sbrk
		pop	cx
		pop	cx
		pop	di
		pop	si
		pop	bp
		retn
_sbrk		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void __cdecl free(void *block)
_free		proc near

block		= word ptr  2

		push	si
		push	di
		mov	si, sp
		mov	bx, [si+6]
		sub	bx, 4
		jb	short loc_91A
		cmp	bx, word_16BA
		jz	short loc_917
		call	sub_957
		jmp	short loc_91A
; ---------------------------------------------------------------------------

loc_917:
		call	sub_91D

loc_91A:
		pop	di
		pop	si
		retn
_free		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_91D		proc near
		cmp	word_16B8, bx
		jz	short loc_946
		mov	si, [bx+2]
		test	byte ptr [si], 1
		jz	short loc_931
		mov	word_16BA, si
		jmp	short loc_951
; ---------------------------------------------------------------------------

loc_931:
		cmp	si, word_16B8
		jz	short loc_944
		mov	bx, si
		call	sub_990
		mov	ax, [bx+2]
		mov	word_16BA, ax
		jmp	short loc_951
; ---------------------------------------------------------------------------

loc_944:
		mov	bx, si

loc_946:
		xor	ax, ax
		mov	word_16B8, ax
		mov	word_16BA, ax
		mov	word_16BC, ax

loc_951:
		push	bx
		call	___brk
		pop	bx
		retn
sub_91D		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_957		proc near
		dec	word ptr [bx]
		cmp	bx, word_16B8
		jz	short loc_977
		mov	si, [bx+2]
		mov	ax, [si]
		test	al, 1
		jnz	short loc_977
		add	ax, [bx]
		mov	[si], ax
		mov	di, [bx]
		add	di, bx
		mov	[di+2],	si
		mov	bx, si
		jmp	short loc_97A
; ---------------------------------------------------------------------------

loc_977:
		call	sub_9AC

loc_97A:
		mov	di, [bx]
		add	di, bx
		mov	ax, [di]
		test	al, 1
		jz	short loc_985
		retn
; ---------------------------------------------------------------------------

loc_985:
		add	[bx], ax
		mov	si, di
		add	si, ax
		mov	[si+2],	bx
		mov	bx, di
sub_957		endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_990		proc near
		mov	di, [bx+6]
		cmp	bx, di
		jz	short loc_9A5
		mov	word_16BC, di
		mov	si, [bx+4]
		mov	[di+4],	si
		mov	[si+6],	di
		retn
; ---------------------------------------------------------------------------

loc_9A5:
		mov	word_16BC, 0
		retn
sub_990		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_9AC		proc near
		mov	si, word_16BC
		or	si, si
		jz	short loc_9C4
		mov	di, [si+6]
		mov	[si+6],	bx
		mov	[di+4],	bx
		mov	[bx+6],	di
		mov	[bx+4],	si
		retn
; ---------------------------------------------------------------------------

loc_9C4:
		mov	word_16BC, bx
		mov	[bx+4],	bx
		mov	[bx+6],	bx
		retn
sub_9AC		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

; void *__cdecl	malloc(size_t size)
_malloc		proc near

_size		= word ptr  2

		push	si
		push	di
		mov	si, sp
		mov	ax, [si+6]
		or	ax, ax
		jz	short loc_A2C
		add	ax, 5
		jb	short loc_A15
		and	ax, 0FFFEh
		cmp	ax, 8
		jnb	short loc_9EA
		mov	ax, 8

loc_9EA:
		cmp	word_16B8, 0
		jz	short loc_A10
		mov	bx, word_16BC
		or	bx, bx
		jz	short loc_A06
		mov	dx, bx

loc_9FB:
		cmp	[bx], ax
		jnb	short loc_A19
		mov	bx, [bx+6]
		cmp	bx, dx
		jnz	short loc_9FB

loc_A06:
		call	sub_A6F
		jmp	short loc_A2C
; ---------------------------------------------------------------------------

loc_A0B:
		call	sub_A98
		jmp	short loc_A2C
; ---------------------------------------------------------------------------

loc_A10:
		call	sub_A2F
		jmp	short loc_A2C
; ---------------------------------------------------------------------------

loc_A15:
		xor	ax, ax
		jmp	short loc_A2C
; ---------------------------------------------------------------------------

loc_A19:
		mov	si, ax
		add	si, 8
		cmp	[bx], si
		jnb	short loc_A0B
		call	sub_990
		inc	word ptr [bx]
		mov	ax, bx
		add	ax, 4

loc_A2C:
		pop	di
		pop	si
		retn
_malloc		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_A2F		proc near
		push	ax
		xor	ax, ax
		push	ax
		push	ax
		call	___sbrk
		pop	bx
		pop	bx
		and	ax, 1
		jz	short loc_A47
		xor	dx, dx
		push	dx
		push	ax
		call	___sbrk
		pop	bx
		pop	bx

loc_A47:
		pop	ax
		push	ax
		xor	bx, bx
		push	bx
		push	ax
		call	___sbrk
		pop	bx
		pop	bx
		cmp	ax, 0FFFFh
		jz	short loc_A6B
		mov	bx, ax
		mov	word_16B8, bx
		mov	word_16BA, bx
		pop	ax
		inc	ax
		mov	[bx], ax
		add	bx, 4
		mov	ax, bx
		retn
; ---------------------------------------------------------------------------

loc_A6B:
		pop	bx
		xor	ax, ax
		retn
sub_A2F		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_A6F		proc near
		push	ax
		xor	bx, bx
		push	bx
		push	ax
		call	___sbrk
		pop	bx
		pop	bx
		cmp	ax, 0FFFFh
		jz	short loc_A94
		mov	bx, ax
		mov	ax, word_16BA
		mov	[bx+2],	ax
		mov	word_16BA, bx
		pop	ax
		inc	ax
		mov	[bx], ax
		add	bx, 4
		mov	ax, bx
		retn
; ---------------------------------------------------------------------------

loc_A94:
		pop	ax
		xor	ax, ax
		retn
sub_A6F		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_A98		proc near
		sub	[bx], ax
		mov	si, bx
		add	si, [bx]
		mov	di, si
		add	di, ax
		inc	ax
		mov	[si], ax
		mov	[si+2],	bx
		mov	[di+2],	si
		add	si, 4
		mov	ax, si
		retn
sub_A98		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __fastcall sub_AB1(size_t	size)
sub_AB1		proc near

var_2		= word ptr -2

		mov	bp, sp
		push	bx
		push	ax
		push	cx
		push	ax		; size
		call	_malloc
		pop	bx
		mov	bx, ax
		or	ax, ax
		jz	short loc_AE0
		push	ds
		pop	es
		assume es:seg000
		cld
		mov	di, ax
		mov	si, [bp+var_2]
		mov	cx, [si]
		add	si, 4
		push	si		; block
		sub	cx, 5
		shr	cx, 1
		rep movsw
		mov	[bp+var_2], ax
		call	_free
		pop	bx
		mov	bx, [bp+var_2]

loc_AE0:
		add	sp, 6
		retn
sub_AB1		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function

sub_AE4		proc near
		mov	ax, dx
		add	dx, 8
		cmp	dx, cx
		ja	short loc_B22
		mov	dx, cx
		cmp	bx, word_16BA
		jnz	short loc_B04
		mov	[bx], ax
		inc	word ptr [bx]
		add	ax, bx
		push	bx
		push	ax
		call	___brk
		pop	bx
		pop	bx
		jmp	short loc_B22
; ---------------------------------------------------------------------------

loc_B04:
		mov	di, bx
		add	di, ax
		mov	[di+2],	bx
		sub	dx, ax
		sub	[bx], dx
		mov	si, di
		add	si, dx
		mov	[si+2],	di
		inc	dx
		mov	[di], dx
		mov	cx, bx
		mov	bx, di
		call	sub_957
		mov	bx, cx

loc_B22:
		add	bx, 4
		retn
sub_AE4		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; void *__cdecl	realloc(void *block, size_t size)
_realloc	proc near

block		= word ptr  8
_size		= word ptr  0Ah

		push	si
		push	di
		push	bp
		mov	bp, sp
		mov	bx, [bp+block]
		mov	ax, [bp+_size]
		or	ax, ax
		jz	short loc_B6C
		or	bx, bx
		jz	short loc_B66
		sub	bx, 4
		mov	cx, [bx]
		dec	cx
		mov	dx, ax
		add	dx, 5
		and	dx, 0FFFEh
		cmp	dx, 8
		jnb	short loc_B4F
		mov	dx, 8

loc_B4F:
		cmp	cx, dx
		jb	short loc_B5F
		ja	short loc_B5A
		add	bx, 4
		jmp	short loc_B62
; ---------------------------------------------------------------------------

loc_B5A:
		call	sub_AE4
		jmp	short loc_B62
; ---------------------------------------------------------------------------

loc_B5F:
		call	sub_AB1

loc_B62:
		mov	ax, bx
		jmp	short loc_B73
; ---------------------------------------------------------------------------

loc_B66:
		push	ax		; size
		call	_malloc
		jmp	short loc_B72
; ---------------------------------------------------------------------------

loc_B6C:
		push	bx		; block
		call	_free
		xor	ax, ax

loc_B72:
		pop	bx

loc_B73:
		pop	bp
		pop	di
		pop	si
		retn
_realloc	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

sub_B77		proc near
		push	ax
		push	cx
		push	dx
		push	bx
		push	sp
		push	bp
		push	si
		push	di
		push	ds
		push	es
		mov	bp, sp
		mov	ax, word ptr dword_16BE
		or	ax, word ptr dword_16BE+2
		jnz	short loc_BB2
		mov	si, 0FFFFh
		push	ds
		mov	ax, 6300h
		clc
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		mov	ax, ds
		pop	ds
		jb	short loc_BA6
		mov	dx, ds
		cmp	ax, dx
		jz	short loc_BA6
		cmp	si, 0FFFFh
		jnz	short loc_BAB

loc_BA6:
		mov	si, offset byte_16C2
		mov	ax, ds

loc_BAB:
		mov	word ptr dword_16BE, si
		mov	word ptr dword_16BE+2, ax

loc_BB2:
		mov	sp, bp
		pop	es
		assume es:nothing
		pop	ds
		pop	di
		pop	si
		pop	bp
		pop	bx
		pop	bx
		pop	dx
		pop	cx
		pop	ax
		retn
sub_B77		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

sub_BBF		proc near

arg_0		= byte ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	al, [bp+arg_0]
		xor	cx, cx
		les	bx, dword_16BE

loc_BCD:
		mov	dx, es:[bx]
		or	dx, dx
		jz	short loc_BDF
		cmp	al, dl
		jb	short loc_BDF
		inc	bx
		inc	bx
		cmp	al, dh
		ja	short loc_BCD
		inc	cx

loc_BDF:
		xchg	ax, cx
		pop	di
		pop	si
		pop	bp
		retn
sub_BBF		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

sub_BE4		proc near

var_2		= word ptr -2
arg_0		= word ptr  4
arg_2		= word ptr  6

		push	bp
		mov	bp, sp
		sub	sp, 2
		push	si
		push	di
		xor	dx, dx
		mov	ax, [bp+arg_0]
		mov	[bp+var_2], ax

loc_BF4:
		mov	bx, [bp+var_2]
		cmp	byte ptr [bx], 0
		jnz	short loc_C00
		xor	dx, dx
		jmp	short loc_C2B
; ---------------------------------------------------------------------------

loc_C00:
		cmp	dx, 1
		jnz	short loc_C0A
		mov	dx, 2
		jmp	short loc_C1E
; ---------------------------------------------------------------------------

loc_C0A:
		mov	bx, [bp+var_2]
		push	word ptr [bx]
		call	sub_BBF
		pop	cx
		or	ax, ax
		jz	short loc_C1C
		mov	dx, 1
		jmp	short loc_C1E
; ---------------------------------------------------------------------------

loc_C1C:
		xor	dx, dx

loc_C1E:
		mov	ax, [bp+var_2]
		cmp	ax, [bp+arg_2]
		jnb	short loc_C2B
		inc	[bp+var_2]
		jmp	short loc_BF4
; ---------------------------------------------------------------------------

loc_C2B:
		or	dx, dx
		jnz	short loc_C34
		mov	ax, 1
		jmp	short loc_C36
; ---------------------------------------------------------------------------

loc_C34:
		xor	ax, ax

loc_C36:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
sub_BE4		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl fflush(FILE *stream)
_fflush		proc near

var_2		= word ptr -2
stream		= word ptr  4

		push	bp
		mov	bp, sp
		sub	sp, 2
		push	si
		push	di
		cmp	[bp+stream], 0
		jnz	short loc_C4F
		call	_flushall
		jmp	short loc_CC5
; ---------------------------------------------------------------------------

loc_C4F:
		mov	bx, [bp+stream]
		mov	ax, [bx+0Eh]
		cmp	ax, [bp+stream]
		jnz	short loc_CC0
		mov	bx, [bp+stream]
		cmp	word ptr [bx], 0
		jl	short loc_C8D
		test	byte ptr [bx+2], 8
		jnz	short loc_C73
		mov	ax, [bp+stream]
		add	ax, 5
		cmp	[bx+0Ah], ax
		jnz	short loc_CC5

loc_C73:
		mov	bx, [bp+stream]
		mov	word ptr [bx], 0
		mov	ax, [bp+stream]
		add	ax, 5
		cmp	[bx+0Ah], ax
		jnz	short loc_CC5
		mov	ax, [bx+8]
		mov	[bx+0Ah], ax
		jmp	short loc_CC5
; ---------------------------------------------------------------------------

loc_C8D:
		mov	bx, [bp+stream]
		mov	ax, [bx+6]
		add	ax, [bx]
		inc	ax
		mov	[bp+var_2], ax
		sub	[bx], ax
		push	ax		; len
		mov	ax, [bx+8]
		mov	[bx+0Ah], ax
		push	ax		; buf
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	___write
		add	sp, 6
		cmp	ax, [bp+var_2]
		jz	short loc_CC5
		mov	bx, [bp+stream]
		test	byte ptr [bx+3], 2
		jnz	short loc_CC5
		or	word ptr [bx+2], 10h

loc_CC0:
		mov	ax, 0FFFFh
		jmp	short loc_CC7
; ---------------------------------------------------------------------------

loc_CC5:
		xor	ax, ax

loc_CC7:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
_fflush		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int flushall(void)
_flushall	proc near

var_6		= word ptr -6
var_4		= word ptr -4
stream		= word ptr -2

		push	bp
		mov	bp, sp
		sub	sp, 6
		push	si
		push	di
		mov	[bp+var_6], 0
		mov	ax, word_162E
		mov	[bp+var_4], ax
		mov	[bp+stream], offset stru_14EE
		jmp	short loc_CFC
; ---------------------------------------------------------------------------

loc_CE7:
		mov	bx, [bp+stream]
		test	byte ptr [bx+2], 3
		jz	short loc_CF8
		push	bx		; stream
		call	_fflush
		pop	cx
		inc	[bp+var_6]

loc_CF8:
		add	[bp+stream], 10h

loc_CFC:
		mov	ax, [bp+var_4]
		dec	[bp+var_4]
		or	ax, ax
		jnz	short loc_CE7
		mov	ax, [bp+var_6]
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
_flushall	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

sub_D0F		proc near

var_2		= word ptr -2
arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		sub	sp, 2
		push	si
		push	di
		mov	bx, [bp+arg_0]
		cmp	word ptr [bx], 0
		jge	short loc_D29
		mov	dx, [bx+6]
		add	dx, [bx]
		inc	dx
		mov	ax, dx
		jmp	short loc_D35
; ---------------------------------------------------------------------------

loc_D29:
		mov	bx, [bp+arg_0]
		mov	ax, [bx]
		cwd
		xor	ax, dx
		sub	ax, dx
		mov	dx, ax

loc_D35:
		mov	[bp+var_2], ax
		mov	bx, [bp+arg_0]
		test	byte ptr [bx+2], 40h
		jnz	short loc_D74
		mov	bx, [bp+arg_0]
		mov	cx, [bx+0Ah]
		cmp	word ptr [bx], 0
		jge	short loc_D6D
		jmp	short loc_D59
; ---------------------------------------------------------------------------

loc_D4E:
		dec	cx
		mov	bx, cx
		cmp	byte ptr [bx], 0Ah
		jnz	short loc_D59
		inc	[bp+var_2]

loc_D59:
		mov	ax, dx
		dec	dx
		or	ax, ax
		jnz	short loc_D4E
		jmp	short loc_D74
; ---------------------------------------------------------------------------

loc_D62:
		mov	bx, cx
		inc	cx
		cmp	byte ptr [bx], 0Ah
		jnz	short loc_D6D
		inc	[bp+var_2]

loc_D6D:
		mov	ax, dx
		dec	dx
		or	ax, ax
		jnz	short loc_D62

loc_D74:
		mov	ax, [bp+var_2]
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn	2
sub_D0F		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl fseek(FILE *stream, __int32 offset, int whence)
_fseek		proc near

stream		= word ptr  4
_offset		= dword	ptr  6
whence		= word ptr  0Ah

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+stream]	; stream
		call	_fflush
		pop	cx
		or	ax, ax
		jz	short loc_D94
		mov	ax, 0FFFFh
		jmp	short loc_DE4
; ---------------------------------------------------------------------------

loc_D94:
		cmp	[bp+whence], 1
		jnz	short loc_DAD
		mov	bx, [bp+stream]
		cmp	word ptr [bx], 0
		jle	short loc_DAD
		push	bx
		call	sub_D0F
		cwd
		sub	word ptr [bp+_offset], ax
		sbb	word ptr [bp+_offset+2], dx

loc_DAD:
		mov	bx, [bp+stream]
		and	word ptr [bx+2], 0FE5Fh
		mov	word ptr [bx], 0
		mov	ax, [bx+8]
		mov	[bx+0Ah], ax
		push	[bp+whence]	; fromwhere
		push	word ptr [bp+_offset+2]
		push	word ptr [bp+_offset] ; offset
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		cmp	dx, 0FFFFh
		jnz	short loc_DE2
		cmp	ax, 0FFFFh
		jnz	short loc_DE2
		mov	ax, 0FFFFh
		jmp	short loc_DE4
; ---------------------------------------------------------------------------

loc_DE2:
		xor	ax, ax

loc_DE4:
		pop	di
		pop	si
		pop	bp
		retn
_fseek		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; __int32 __cdecl ftell(FILE *stream)
_ftell		proc near

var_8		= word ptr -8
var_6		= word ptr -6
_offset		= dword	ptr -4
stream		= word ptr  4

		push	bp
		mov	bp, sp
		sub	sp, 8
		push	si
		push	di
		mov	ax, 1
		push	ax		; fromwhere
		xor	ax, ax
		push	ax
		push	ax		; offset
		mov	bx, [bp+stream]
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		mov	word ptr [bp+_offset+2],	dx
		mov	word ptr [bp+_offset], ax
		cmp	dx, 0FFFFh
		jnz	short loc_E19
		cmp	ax, 0FFFFh
		jnz	short loc_E19
		jmp	loc_EA9
; ---------------------------------------------------------------------------

loc_E19:
		mov	bx, [bp+stream]
		cmp	word ptr [bx], 0
		jge	short loc_E9C
		mov	al, [bx+4]
		cbw
		add	ax, ax
		mov	bx, ax
		test	byte ptr (word_1630+1)[bx], 8
		jz	short loc_E8D
		mov	ax, 2
		push	ax		; fromwhere
		xor	ax, ax
		push	ax
		push	ax		; offset
		mov	bx, [bp+stream]
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		mov	[bp+var_6], dx
		mov	[bp+var_8], ax
		cmp	dx, 0FFFFh
		jnz	short loc_E58
		cmp	ax, 0FFFFh
		jnz	short loc_E58
		jmp	short loc_EAF
; ---------------------------------------------------------------------------

loc_E58:
		xor	ax, ax
		push	ax		; fromwhere
		push	word ptr [bp+_offset+2]
		push	word ptr [bp+_offset] ; offset
		mov	bx, [bp+stream]
		mov	al, [bx+4]
		cbw
		push	ax		; handle
		call	_lseek
		add	sp, 8
		cmp	dx, 0FFFFh
		jnz	short loc_E81
		cmp	ax, 0FFFFh
		jnz	short loc_E81
		mov	dx, 0FFFFh
		mov	ax, 0FFFFh
		jmp	short loc_EAF
; ---------------------------------------------------------------------------

loc_E81:
		mov	dx, [bp+var_6]
		mov	ax, [bp+var_8]
		mov	word ptr [bp+_offset+2], dx
		mov	word ptr [bp+_offset], ax

loc_E8D:
		push	[bp+stream]
		call	sub_D0F
		cwd
		add	word ptr [bp+_offset], ax
		adc	word ptr [bp+_offset+2], dx
		jmp	short loc_EA9
; ---------------------------------------------------------------------------

loc_E9C:
		push	[bp+stream]
		call	sub_D0F
		cwd
		sub	word ptr [bp+_offset], ax
		sbb	word ptr [bp+_offset+2], dx

loc_EA9:
		mov	dx, word ptr [bp+_offset+2]
		mov	ax, word ptr [bp+_offset]

loc_EAF:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
_ftell		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl setvbuf(FILE *stream, char *buf, int type, size_t	size)
_setvbuf	proc near

stream		= word ptr  4
_buf		= word ptr  6
_type		= word ptr  8
_size		= word ptr  0Ah

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	bx, [bp+stream]
		mov	ax, [bx+0Eh]
		cmp	ax, [bp+stream]
		jz	short loc_EC8
		jmp	loc_F73
; ---------------------------------------------------------------------------

loc_EC8:
		cmp	[bp+_type], 2
		jle	short loc_ED1
		jmp	loc_F73
; ---------------------------------------------------------------------------

loc_ED1:
		cmp	[bp+_size], 7FFFh
		jbe	short loc_EDB
		jmp	loc_F73
; ---------------------------------------------------------------------------

loc_EDB:
		cmp	word_16D0, 0
		jnz	short loc_EF1
		cmp	[bp+stream], offset stru_14FE
		jnz	short loc_EF1
		mov	word_16D0, 1
		jmp	short loc_F05
; ---------------------------------------------------------------------------

loc_EF1:
		cmp	word_16CE, 0
		jnz	short loc_F05
		cmp	[bp+stream], offset stru_14EE
		jnz	short loc_F05
		mov	word_16CE, 1

loc_F05:
		mov	bx, [bp+stream]
		cmp	word ptr [bx], 0
		jz	short loc_F1C
		mov	ax, 1
		push	ax		; whence
		xor	ax, ax
		push	ax
		push	ax		; offset
		push	bx		; stream
		call	_fseek
		add	sp, 8

loc_F1C:
		mov	bx, [bp+stream]
		test	byte ptr [bx+2], 4
		jz	short loc_F2C
		push	word ptr [bx+8]	; block
		call	_free
		pop	cx

loc_F2C:
		mov	bx, [bp+stream]
		and	word ptr [bx+2], 0FFF3h
		mov	word ptr [bx+6], 0
		mov	ax, [bp+stream]
		add	ax, 5
		mov	[bx+8],	ax
		mov	[bx+0Ah], ax
		cmp	[bp+_type], 2
		jz	short loc_F94
		cmp	[bp+_size], 0
		jbe	short loc_F94
		mov	off_14E8, offset __xfflush
		cmp	[bp+_buf], 0
		jnz	short loc_F78
		push	[bp+_size]	; size
		call	_malloc
		pop	cx
		mov	[bp+_buf], ax
		or	ax, ax
		jz	short loc_F73
		mov	bx, [bp+stream]
		or	word ptr [bx+2], 4
		jmp	short loc_F78
; ---------------------------------------------------------------------------

loc_F73:
		mov	ax, 0FFFFh
		jmp	short loc_F96
; ---------------------------------------------------------------------------

loc_F78:
		mov	bx, [bp+stream]
		mov	ax, [bp+_buf]
		mov	[bx+0Ah], ax
		mov	[bx+8],	ax
		mov	ax, [bp+_size]
		mov	[bx+6],	ax
		cmp	[bp+_type], 1
		jnz	short loc_F94
		or	word ptr [bx+2], 8

loc_F94:
		xor	ax, ax

loc_F96:
		pop	di
		pop	si
		pop	bp
		retn
_setvbuf	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; size_t __cdecl strlen(const char *s)
_strlen		proc near

s		= word ptr  4

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	ax, ds
		mov	es, ax
		assume es:seg000
		mov	di, [bp+s]
		xor	ax, ax
		cld
		mov	cx, 0FFFFh
		repne scasb
		xchg	ax, cx
		not	ax
		dec	ax
		pop	di
		pop	si
		pop	bp
		retn
_strlen		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl __write(int handle, void *buf, unsigned int len)
___write	proc near

var_8A		= byte ptr -8Ah
var_8		= word ptr -8
var_5		= byte ptr -5
var_4		= word ptr -4
var_2		= word ptr -2
handle		= word ptr  4
_buf		= word ptr  6
len		= word ptr  8

		push	bp
		mov	bp, sp
		sub	sp, 8Ah
		push	si
		push	di
		mov	ax, [bp+handle]
		cmp	ax, word_162E
		jb	short loc_FD2
		mov	ax, 6
		push	ax
		call	__IOERROR
		jmp	loc_10D5
; ---------------------------------------------------------------------------

loc_FD2:
		mov	ax, [bp+len]
		inc	ax
		cmp	ax, 2
		jnb	short loc_FE0
		xor	ax, ax
		jmp	loc_10D5
; ---------------------------------------------------------------------------

loc_FE0:
		mov	bx, [bp+handle]
		add	bx, bx
		test	byte ptr (word_1630+1)[bx], 8
		jz	short loc_FFD
		mov	ax, 2
		push	ax		; fromwhere
		xor	ax, ax
		push	ax
		push	ax		; offset
		push	[bp+handle]	; handle
		call	_lseek
		add	sp, 8

loc_FFD:
		mov	bx, [bp+handle]
		add	bx, bx
		test	byte ptr (word_1630+1)[bx], 40h
		jnz	short loc_101B
		push	[bp+len]	; len
		push	[bp+_buf]	; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		jmp	loc_10D5
; ---------------------------------------------------------------------------

loc_101B:
		mov	bx, [bp+handle]
		add	bx, bx
		and	word_1630[bx], 0FDFFh
		mov	ax, [bp+_buf]
		mov	[bp+var_8], ax
		mov	ax, [bp+len]
		mov	[bp+var_4], ax
		jmp	short loc_108D
; ---------------------------------------------------------------------------

loc_1034:
		dec	[bp+var_4]
		mov	bx, [bp+var_8]
		inc	[bp+var_8]
		mov	al, [bx]
		mov	[bp+var_5], al
		cmp	al, 0Ah
		jnz	short loc_104C
		mov	bx, cx
		mov	byte ptr [bx], 0Dh
		inc	cx

loc_104C:
		mov	bx, cx
		mov	al, [bp+var_5]
		mov	[bx], al
		inc	cx
		lea	ax, [bp+var_8A]
		mov	dx, cx
		sub	dx, ax
		cmp	dx, 80h
		jl	short loc_1091
		mov	dx, cx
		sub	dx, ax
		mov	[bp+var_2], dx
		push	dx		; len
		push	ax		; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		mov	dx, ax
		cmp	ax, [bp+var_2]
		jz	short loc_108D
		cmp	dx, 0FFFFh
		jnz	short loc_1085
		mov	ax, 0FFFFh
		jmp	short loc_10D0
; ---------------------------------------------------------------------------

loc_1085:
		mov	ax, [bp+len]
		sub	ax, [bp+var_4]
		jmp	short loc_10CB
; ---------------------------------------------------------------------------

loc_108D:
		lea	cx, [bp+var_8A]

loc_1091:
		cmp	[bp+var_4], 0
		jnz	short loc_1034
		lea	ax, [bp+var_8A]
		mov	dx, cx
		sub	dx, ax
		mov	[bp+var_2], dx
		mov	ax, dx
		or	ax, ax
		jbe	short loc_10D2
		push	dx		; len
		lea	ax, [bp+var_8A]
		push	ax		; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		mov	dx, ax
		cmp	ax, [bp+var_2]
		jz	short loc_10D2
		cmp	dx, 0FFFFh
		jnz	short loc_10C8
		mov	ax, 0FFFFh
		jmp	short loc_10D0
; ---------------------------------------------------------------------------

loc_10C8:
		mov	ax, [bp+len]

loc_10CB:
		add	ax, dx
		sub	ax, [bp+var_2]

loc_10D0:
		jmp	short loc_10D5
; ---------------------------------------------------------------------------

loc_10D2:
		mov	ax, [bp+len]

loc_10D5:
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
___write	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl _rtl_write(int handle, const void	*buf, unsigned int len)
__rtl_write	proc near

handle		= word ptr  4
_buf		= word ptr  6
len		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	bx, [bp+handle]
		add	bx, bx
		test	byte ptr [bx+1630h], 1
		jz	short loc_10F2
		mov	ax, 5
		push	ax
		jmp	short loc_1111
; ---------------------------------------------------------------------------

loc_10F2:
		mov	ah, 40h
		mov	bx, [bp+handle]
		mov	cx, [bp+len]
		mov	dx, [bp+_buf]
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		jb	short loc_1110
		push	ax
		mov	bx, [bp+handle]
		add	bx, bx
		or	word_1630[bx], 1000h
		pop	ax
		jmp	short loc_1114
; ---------------------------------------------------------------------------

loc_1110:
		push	ax

loc_1111:
		call	__IOERROR

loc_1114:
		pop	di
		pop	si
		pop	bp
		retn
__rtl_write	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

; int __cdecl _write(int handle, const void *buf, unsigned int len)
__write		proc near

handle		= word ptr  4
_buf		= word ptr  6
len		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		push	[bp+len]	; len
		push	[bp+_buf]	; buf
		push	[bp+handle]	; handle
		call	__rtl_write
		add	sp, 6
		pop	di
		pop	si
		pop	bp
		retn
__write		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: library function bp-based	frame

__xfflush	proc near

var_4		= word ptr -4
stream		= word ptr -2

		push	bp
		mov	bp, sp
		sub	sp, 4
		push	si
		push	di
		mov	[bp+var_4], 4
		mov	[bp+stream], offset stru_14EE
		jmp	short loc_1159
; ---------------------------------------------------------------------------

loc_1144:
		mov	bx, [bp+stream]
		test	byte ptr [bx+2], 3
		jz	short loc_1152
		push	bx		; stream
		call	_fflush
		pop	cx

loc_1152:
		dec	[bp+var_4]
		add	[bp+stream], 10h

loc_1159:
		cmp	[bp+var_4], 0
		jnz	short loc_1144
		pop	di
		pop	si
		mov	sp, bp
		pop	bp
		retn
__xfflush	endp

; ---------------------------------------------------------------------------
word_1165	dw 0

; =============== S U B	R O U T	I N E =======================================

; BCC v4.x/5.x DOS runtime
; Attributes: library function

unknown_libname_1 proc near

; FUNCTION CHUNK AT 124D SIZE 00000059 BYTES

		pop	word_16D8
		pop	word_16DA
		pop	word_16DC
		mov	cs:word_1165, ds
		mov	word_16DE, si
		mov	word_16E0, di
		cld
		mov	es, word_1306
		assume es:nothing
		mov	si, 80h
		xor	ah, ah
		lods	byte ptr es:[si]
		inc	ax
		mov	bp, es
		xchg	dx, si
		xchg	ax, bx
		mov	si, word_1300
		inc	si
		inc	si
		mov	cx, 1
		cmp	byte ptr word_1308, 3
		jb	short loc_11B3
		mov	es, word_1302
		mov	di, si
		mov	cl, 7Fh
		xor	al, al
		repne scasb
		jcxz	short loc_11FA
		xor	cl, 7Fh

loc_11B3:
		push	ax
		mov	ax, cx
		add	ax, bx
		inc	ax
		and	ax, 0FFFEh
		mov	di, sp
		sub	di, ax
		jb	short loc_11FA
		mov	sp, di
		push	es
		pop	ds
		push	ss
		pop	es
		push	cx
		dec	cx
		rep movsb
		xor	al, al
		stosb
		mov	ds, bp
		xchg	si, dx
		xchg	bx, cx
		mov	ax, bx
		mov	dx, ax
		inc	bx

loc_11DA:
		call	sub_11FD
		ja	short loc_11EA

loc_11DF:
		jb	short loc_124D
		cmp	al, 0Dh
		jz	short loc_11F6
		call	sub_11FD
		ja	short loc_11DF

loc_11EA:
		cmp	al, 20h
		jz	short loc_11F6
		cmp	al, 0Dh
		jz	short loc_11F6
		cmp	al, 9
		jnz	short loc_11DA

loc_11F6:
		xor	al, al
		jmp	short loc_11DA
; ---------------------------------------------------------------------------

loc_11FA:
		jmp	sub_63A
unknown_libname_1 endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================


sub_11FD	proc near
		or	ax, ax
		jz	short loc_1208
		inc	dx
		stosb
		or	al, al
		jnz	short loc_1208
		inc	bx

loc_1208:
		xchg	ah, al
		xor	al, al
		stc
		jcxz	short locret_124C
		lodsb
		dec	cx
		cmp	dh, 1
		jz	short loc_1232
		xor	dh, dh
		push	ax
		push	bx
		push	cx
		push	dx
		push	ds
		push	es
		mov	ds, cs:word_1165
		push	ax
		call	sub_BBF
		or	ax, ax
		pop	cx
		pop	es
		pop	ds
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jz	short loc_1234

loc_1232:
		inc	dh

loc_1234:
		cmp	dh, 0
		jnz	short loc_124A
		sub	al, 22h
		jz	short locret_124C
		add	al, 22h
		cmp	al, 5Ch
		jnz	short loc_124A
		cmp	byte ptr [si], 22h
		jnz	short loc_124A
		lodsb
		dec	cx

loc_124A:
		or	si, si

locret_124C:
		retn
sub_11FD	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR unknown_libname_1

loc_124D:
		pop	cx
		xor	dh, dh
		add	cx, dx
		mov	ds, cs:word_1165
		mov	word_16D4, bx
		inc	bx
		add	bx, bx
		mov	si, sp
		mov	bp, sp
		sub	bp, bx
		jb	short loc_11FA
		mov	sp, bp
		mov	word_16D6, bp

loc_126C:
		jcxz	short loc_127C
		mov	[bp+0],	si
		add	bp, 2

loc_1274:
		lods	byte ptr ss:[si]
		or	al, al
		loopne	loc_1274
		jz	short loc_126C

loc_127C:
		xor	ax, ax
		mov	[bp+0],	ax
		mov	ds, cs:word_1165
		mov	si, word_16DE
		mov	di, word_16E0
		push	word_16DC
		push	word_16DA
		mov	ax, word_16D4
		mov	argc, ax
		mov	ax, word_16D6
		mov	argv, ax
		jmp	word_16D8
; END OF FUNCTION CHUNK	FOR unknown_libname_1
; ---------------------------------------------------------------------------
		db 10 dup(0)
aBorlandCCopyri	db 'Borland C++ - Copyright 1993 Borland Intl.',0
; char buf[]
buf		db 'Divide error',0Dh,0Ah,0
dword_12EA	dd 0
dword_12EE	dd 0
dword_12F2	dd 0
dword_12F6	dd 0
; int argc
argc		dw 0
; char **argv
argv		dw 0
; char **envp
envp		dw 0
word_1300	dw 0
word_1302	dw 0
word_1304	dw 0
word_1306	dw 0
word_1308	dw 0
word_130A	dw 0
		dw 0FFFFh
		dw offset edata@
off_1310	dw offset edata@
		dw 0
word_1314	dw 0
		dw 0
word_1318	dw 0
		dw 0
word_131C	dw 0
byte_131E	db 0
unk_131F	db    1
		db    0
		db    1
		db    0
		db    0
aYume_cfg	db 'yume.cfg',0
aYumeconfig	db 'YUMEConfig',0
aUmx		db 0Ah
		db 0Ah
		db '東方夢時空用　 常駐プログラム　RES_YUME.com Version1.00       (c)zun 1997',0Ah,0
aVavVBavVVvvVV	db 'わたし、まだいませんよぉ',0Ah
		db 0Ah,0
aVVcvVcbavVIqvj	db 'さよなら、また会えたらいいな',0Ah
		db 0Ah,0
aVV		db 'そんなオプション付けられても、困るんですけど',0Ah
		db 0Ah,0
aVavVBavVVVvvVV	db 'わたし、すでにいますよぉ',0Ah
		db 0Ah,0
aNVVVV		db '作れません、わたしの居場所がないの！',0Ah
		db 0Ah,0
aVVVVBavcvivVnv	db 'それでは、よろしくお願いします',0Ah
		db 0Ah
		db 0,0
aMasters_libVer	db 'MASTERS.LIB Version 0.23 Copyright (c)1995 A.Koizuka,Kazumi,steelman,iR,All rights reserved.',0
		db 0
word_14B0	dw 0A800h
word_14B2	dw 3E80h
		db 90h
		db    1
		db  50h	; P
		db    0
		db    0
		db    0
		db  55h	; U
		db    0
aPal98Grb	db 'pal98 grb',0
aAbnormalProgra	db 'Abnormal program termination',0Dh,0Ah,0
		db 0
word_14E6	dw 0
off_14E8	dw offset sub_696
off_14EA	dw offset sub_696
off_14EC	dw offset sub_696
stru_14EE	FILE <0, 209h, 0, 0, 0,	0, 0, 0, offset	stru_14EE>
stru_14FE	FILE <0, 20Ah, 1, 0, 0,	0, 0, 0, offset	stru_14FE>
stru_150E	FILE <0, 202h, 2, 0, 0,	0, 0, 0, offset	stru_150E>
stru_151E	FILE <0, 243h, 3, 0, 0,	0, 0, 0, offset	stru_151E>
stru_152E	FILE <0, 242h, 4, 0, 0,	0, 0, 0, offset	stru_152E>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
		FILE <0>
word_162E	dw 14h
word_1630	dw 6001h
		dw 6002h
		dw 6002h
		dw 0A004h
		dw 0A002h
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
		dw 0
word_1658	dw 0
word_165A	dw 0
byte_165C	db 0
		db  13h
		db    2
		db    2
		db    4
		db    5
		db    6
		db    8
		db    8
		db    8
		db  14h
		db  15h
		db    5
		db  13h
		db  0Eh
		db    5
		db    5
		db  11h
		db    2
		db  1Eh
		db  29h	; )
		db  2Ch	; ,
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  29h	; )
		db  2Ch	; ,
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db    5
		db    5
		db  29h	; )
		db  17h
		db  17h
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Fh
		db  2Ch	; ,
		db  23h	; #
		db    2
		db  2Ch	; ,
		db  0Fh
		db  2Ah	; *
		db  28h	; (
		db  28h	; (
		db  28h	; (
		db  13h
		db  1Bh
		db  1Ch
		db    2
		db    2
		db    5
		db  0Fh
		db    2
		db  17h
		db  28h	; (
		db  2Ah	; *
		db  13h
		db  2Ah	; *
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  0Eh
		db  23h	; #
		db  0Eh
		db  1Ch
		db  28h	; (
		db  17h
		db  23h	; #
		db  25h	; %
		db  13h
		db  28h	; (
		db    0
word_16B6	dw 1000h
word_16B8	dw 0
word_16BA	dw 0
word_16BC	dw 0
dword_16BE	dd 0
byte_16C2	db 0Ch dup(0)
word_16CE	dw 0
word_16D0	dw 0
word_16D2	dw 30h
word_16D4	dw 0
word_16D6	dw 0
word_16D8	dw 0
word_16DA	dw 0
word_16DC	dw 0
word_16DE	dw 0
word_16E0	dw 0
InitStart	db    0
		db    2
		dw offset __setupio
		db    0
		db    0
		db    0
		db  0Fh
		dw offset sub_B77
		db    0
		db    0
		db    0
		db  10h
		dw offset unknown_libname_1 ; BCC v4.x/5.x DOS runtime
		db    ?	;
		db    ?	;
bdata@		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
edata@		db ?
seg000		ends


		end start
